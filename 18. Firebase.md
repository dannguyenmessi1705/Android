# Firebase Android (Realtime Database) — Hướng dẫn cho người mới bắt đầu

Tài liệu này hướng dẫn cách tích hợp **Firebase Realtime Database** vào Android app (Kotlin), và cách **ghi/đọc dữ liệu đơn giản** cũng như **ghi/đọc object**. Nội dung được viết dựa trên cấu hình của project hiện tại:

- Module: `app`
- Package/ApplicationId: `com.didan.android.firebase.dbrt`
- Gradle Kotlin DSL: `build.gradle.kts`, `app/build.gradle.kts`
- Plugin: `com.google.gms.google-services`
- Firebase: dùng **Firebase BoM** + **Realtime Database**

## Mục lục

1. [Adding Firebase to Apps](#1-adding-firebase-to-apps)
2. [Write Simple Data](#2-write-simple-data)
3. [Reading Simple Data from Firebase](#3-reading-simple-data-from-firebase)
4. [Writing Custom Objects to Firebase](#4-writing-custom-objects-to-firebase)
5. [Reading Custom Objects](#5-reading-custom-objects)
6. [Ghi chú nâng cao & lỗi thường gặp](#6-ghi-chú-nâng-cao--lỗi-thường-gặp)

---

## 1. Adding Firebase to Apps

### 1.1. Tạo Firebase Project

1. Vào Firebase Console → tạo project mới.
2. (Tuỳ chọn) Bật Google Analytics cho project.

### 1.2. Thêm Android App vào Firebase Project

Trong Firebase Console:

1. Chọn **Add app** → **Android**
2. Nhập **Android package name** đúng với app:
   - Trong project này: `com.didan.android.firebase.dbrt` (xem `app/build.gradle.kts` ở `defaultConfig.applicationId`)
3. (Khuyến nghị) Thêm SHA-1 nếu bạn sẽ dùng Authentication/Google Sign-In sau này.
4. Tải file cấu hình **`google-services.json`**.

### 1.3. Đặt `google-services.json` đúng vị trí

Đặt file tại:

- `app/google-services.json`

> Nếu đặt sai thư mục (ví dụ để ở root project), build sẽ không nhận cấu hình Firebase.

### 1.4. Cấu hình Gradle (đúng với project Kotlin DSL)

#### a) Root Gradle: khai báo plugin Google Services

File: `build.gradle.kts`

Project hiện tại đang có:

```kotlin
plugins {
    id("com.google.gms.google-services") version "4.4.4" apply false
}
```

#### b) App module: apply plugin + thêm dependency Firebase

File: `app/build.gradle.kts`

Project hiện tại đang có:

```kotlin
plugins {
    id("com.google.gms.google-services")
}

dependencies {
    // Firebase BOM
    implementation(platform("com.google.firebase:firebase-bom:34.8.0"))

    // Analytics (tuỳ chọn nhưng thường bật sẵn)
    implementation("com.google.firebase:firebase-analytics")

    // Realtime Database
    implementation("com.google.firebase:firebase-database")
}
```

**Khuyến nghị cho Kotlin (nâng cao thêm):** nếu bạn muốn dùng các Kotlin extension như `Firebase.database(...)` hoặc `snapshot.getValue<T>()`, hãy thêm KTX:

```kotlin
dependencies {
    implementation("com.google.firebase:firebase-database-ktx")
}
```

> Trong project demo hiện tại, code đang dùng `com.google.firebase.database.database` và `com.google.firebase.database.getValue`, nên bạn nên dùng `firebase-database-ktx` để tránh lỗi import/compile tuỳ môi trường.

### 1.5. Bật Realtime Database trên Firebase Console

1. Firebase Console → **Build** → **Realtime Database**
2. **Create Database**
3. Chọn region (ví dụ `asia-southeast1`) → tạo database
4. Chọn rule:
   - Học/demo nhanh: **Test mode** (tạm thời)
   - Thực tế: nên khóa bằng Authentication (xem phần “Ghi chú nâng cao”)

### 1.6. Chạy app

Sync Gradle → chạy app. Nếu gặp lỗi “Permission denied” khi đọc/ghi, thường là do **Realtime Database Rules** (xem mục 6).

---

## 2. Write Simple Data

### 2.1. Lấy `DatabaseReference`

Bạn cần một điểm tham chiếu tới database.

**Cách 1 (giống project demo): truyền Database URL**

```kotlin
import com.google.firebase.Firebase
import com.google.firebase.database.DatabaseReference
import com.google.firebase.database.database

lateinit var database: DatabaseReference

database =
    Firebase.database("https://<your-db-name>.asia-southeast1.firebasedatabase.app")
        .reference
```

Trong project này, `MainActivity.kt` đang dùng URL dạng:

```text
https://fir-kotlin-77e8d-default-rtdb.asia-southeast1.firebasedatabase.app
```

**Cách 2: dùng database mặc định (khi chỉ có 1 DB)**

```kotlin
database = Firebase.database.reference
```

### 2.2. Ghi dữ liệu đơn giản (String/Number/Boolean)

Ví dụ ghi giá vàng:

```kotlin
database.child("price").setValue("1930 $")
```

Ghi số:

```kotlin
database.child("counter").setValue(1)
```

Ghi boolean:

```kotlin
database.child("feature_enabled").setValue(true)
```

### 2.3. Xử lý kết quả ghi (thành công/thất bại)

Để biết ghi có thành công không:

```kotlin
database.child("price")
    .setValue("1930 $")
    .addOnSuccessListener { /* cập nhật UI, log... */ }
    .addOnFailureListener { e -> /* xử lý lỗi */ }
```

### 2.4. Xoá dữ liệu

```kotlin
database.child("price").removeValue()
```

Hoặc set `null` cũng tương đương xoá:

```kotlin
database.child("price").setValue(null)
```

### 2.5. Ghi nhiều field một lần (update)

Nếu bạn muốn update nhiều nhánh mà không ghi đè toàn bộ node:

```kotlin
val updates = mapOf(
    "price" to "1930 $",
    "feature_enabled" to true
)
database.updateChildren(updates)
```

### 2.6. Tạo danh sách bằng `push()`

Với dữ liệu dạng list, dùng `push()` để tạo key duy nhất:

```kotlin
val key = database.child("logs").push().key
database.child("logs").child(key!!).setValue("App opened")
```

---

## 3. Reading Simple Data from Firebase

Realtime Database có 2 kiểu đọc phổ biến:

- **Nghe thay đổi liên tục**: `addValueEventListener(...)` (mỗi khi dữ liệu thay đổi sẽ callback)
- **Đọc 1 lần**: `addListenerForSingleValueEvent(...)` (chỉ callback 1 lần)

### 3.1. Đọc liên tục (giống project demo)

Ví dụ đọc `price`:

```kotlin
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.ValueEventListener

val priceRef = database.child("price")

val listener = object : ValueEventListener {
    override fun onDataChange(snapshot: DataSnapshot) {
        val price = snapshot.getValue<String>() // cần firebase-database-ktx
        // hoặc: val price = snapshot.getValue(String::class.java)
        // cập nhật UI
    }

    override fun onCancelled(error: DatabaseError) {
        // thường do Rules chặn, mất mạng, hoặc path không hợp lệ
    }
}

priceRef.addValueEventListener(listener)
```

### 3.2. Đọc 1 lần

```kotlin
priceRef.addListenerForSingleValueEvent(object : ValueEventListener {
    override fun onDataChange(snapshot: DataSnapshot) {
        val price = snapshot.getValue(String::class.java)
    }

    override fun onCancelled(error: DatabaseError) {}
})
```

### 3.3. Gỡ listener (khuyến nghị)

Nếu bạn dùng `addValueEventListener`, hãy gỡ khi không cần nữa (tránh leak + callback khi Activity đã stop):

```kotlin
override fun onStop() {
    super.onStop()
    priceRef.removeEventListener(listener)
}
```

---

## 4. Writing Custom Objects to Firebase

### 4.1. Tạo model (data class)

Trong project demo đang có:

File: `app/src/main/java/com/didan/android/firebase/dbrt/User.kt`

```kotlin
data class User(
    val username: String? = "",
    val password: String? = ""
)
```

**Lưu ý quan trọng:**

- Nên có **giá trị mặc định** (hoặc constructor rỗng) để Firebase có thể map dữ liệu khi đọc về.
- Tên field trong Firebase nên khớp với tên property (`username`, `password`) để map tự động.

### 4.2. Ghi object

Ví dụ (giống demo):

```kotlin
val user1 = User("didan", "12345")
database.child("Users").setValue(user1)
```

**Cảnh báo:** `setValue` tại `Users` sẽ **ghi đè toàn bộ node `Users`**.

Thực tế thường lưu theo ID:

```kotlin
val userId = "u001" // ví dụ, hoặc lấy từ FirebaseAuth UID
database.child("Users").child(userId).setValue(user1)
```

Hoặc tạo ID tự động:

```kotlin
val userId = database.child("Users").push().key!!
database.child("Users").child(userId).setValue(user1)
```

---

## 5. Reading Custom Objects

### 5.1. Đọc 1 object

Trong demo hiện tại, code đọc `Users` và map về `User`:

```kotlin
val usersRef = database.child("Users")

usersRef.addValueEventListener(object : ValueEventListener {
    override fun onDataChange(snapshot: DataSnapshot) {
        val user = snapshot.getValue<User>() // cần firebase-database-ktx
        // hoặc: val user = snapshot.getValue(User::class.java)
    }

    override fun onCancelled(error: DatabaseError) {}
})
```

### 5.2. Đọc danh sách object (khi `Users` là nhiều user theo ID)

Khi bạn lưu dạng:

```
Users
  u001: { username: "...", password: "..." }
  u002: { username: "...", password: "..." }
```

Thì đọc list như sau:

```kotlin
usersRef.addListenerForSingleValueEvent(object : ValueEventListener {
    override fun onDataChange(snapshot: DataSnapshot) {
        val users = snapshot.children.mapNotNull { child ->
            child.getValue<User>() // hoặc child.getValue(User::class.java)
        }
        // users là List<User>
    }

    override fun onCancelled(error: DatabaseError) {}
})
```

Nếu bạn cần lấy cả key (ID):

```kotlin
val usersWithId = snapshot.children.mapNotNull { child ->
    val id = child.key ?: return@mapNotNull null
    val user = child.getValue<User>() ?: return@mapNotNull null
    id to user
}
```

---

## 6. Ghi chú nâng cao & lỗi thường gặp

### 6.1. Lỗi `Permission denied`

Nguyên nhân thường gặp nhất là **Realtime Database Rules** đang chặn đọc/ghi.

- Demo/học nhanh (không an toàn cho production):

```json
{
  "rules": {
    ".read": true,
    ".write": true
  }
}
```

- Khuyến nghị cơ bản (cần Authentication):

```json
{
  "rules": {
    ".read": "auth != null",
    ".write": "auth != null"
  }
}
```

### 6.2. Vì sao `setValue()` “mất dữ liệu”?

`setValue()` tại một node sẽ **ghi đè** toàn bộ node đó. Nếu bạn muốn cập nhật 1 phần, dùng:

- `updateChildren(...)`
- Hoặc setValue sâu hơn: `child("Users").child(userId).setValue(...)`

### 6.3. Dữ liệu thay đổi liên tục và vòng đời Activity

`addValueEventListener(...)` sẽ tiếp tục nhận callback khi dữ liệu thay đổi. Vì vậy:

- Dùng `addListenerForSingleValueEvent(...)` nếu chỉ cần đọc 1 lần.
- Nếu cần nghe liên tục, hãy `removeEventListener(...)` trong `onStop()` hoặc `onDestroy()`.

### 6.4. Gợi ý cấu trúc dữ liệu (dễ mở rộng)

Thay vì:

```
Users: { username: "...", password: "..." }
```

Hãy dùng:

```
Users
  <userId>
    username: "..."
    password: "..."
```

Để dễ lưu nhiều users, phân quyền theo user, và truy vấn theo node con.

### 6.5. INTERNET permission (nếu gặp lỗi mạng)

Thông thường, dependency Firebase sẽ tự merge quyền mạng vào manifest. Tuy nhiên nếu bạn gặp vấn đề kết nối (đặc biệt với project tối giản), hãy kiểm tra `AndroidManifest.xml` có:

```xml
<uses-permission android:name="android.permission.INTERNET" />
```
