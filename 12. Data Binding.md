# Data Binding

Tài liệu này giới thiệu Data Binding trong Android theo cách dễ hiểu cho người mới bắt đầu. Bạn sẽ học cách bật Data Binding, khai báo biến trong layout, xử lý sự kiện click và sử dụng two-way data binding.

## Data Binding in Android

Data Binding là thư viện cho phép bạn liên kết dữ liệu (data) với giao diện (View) trực tiếp trong XML. Thay vì phải gọi `findViewById()` và gán giá trị thủ công, bạn chỉ cần khai báo biến và biểu thức trong layout, Android sẽ tự cập nhật giao diện khi dữ liệu thay đổi.

### Khi nào nên dùng Data Binding?

- Muốn giảm boilerplate trong Activity/Fragment.
- Muốn binding dữ liệu trực tiếp từ ViewModel hoặc đối tượng dữ liệu.
- Muốn xử lý sự kiện click trực tiếp trong XML.

### Bật Data Binding trong dự án

Mở `build.gradle` (module app) và bật Data Binding:

```gradle
android {
    buildFeatures {
        dataBinding true
    }
}
```

Sau khi bật, Android sẽ tạo ra lớp binding tương ứng với mỗi layout có thẻ `<layout>`.

## Apps Using Data Binding

Nhiều ứng dụng Android dùng Data Binding để:

- Hiển thị danh sách sản phẩm/đơn hàng với dữ liệu thay đổi liên tục.
- Kết nối UI với ViewModel trong kiến trúc MVVM.
- Tối ưu việc hiển thị trạng thái (loading, success, error).

Ví dụ: App thương mại điện tử có thể binding trực tiếp tên sản phẩm, giá và trạng thái còn hàng vào UI mà không cần cập nhật thủ công.

## Data Binding Variables

Để dùng Data Binding, layout cần bọc bằng thẻ `<layout>` và khai báo `<data>`.

### Ví dụ khai báo biến

```xml
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="user"
            type="com.example.app.User" />
    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{user.name}" />
    </LinearLayout>
</layout>
```

### Gán dữ liệu trong Activity/Fragment

```kotlin
class ProfileActivity : AppCompatActivity() {
    private lateinit var binding: ActivityProfileBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityProfileBinding.inflate(layoutInflater)
        setContentView(binding.root)

        val user = User(name = "Nguyen Van A")
        binding.user = user
    }
}
```

Lưu ý: Tên lớp binding được tạo dựa trên tên file layout. Ví dụ `activity_profile.xml` sẽ tạo `ActivityProfileBinding`.

## Handling Click Events with Data Binding

Bạn có thể xử lý click ngay trong XML bằng cách binding tới một lớp xử lý riêng. Cách này gọn và dễ tái sử dụng.

### Ví dụ: VehicleClickHandlers

**Kotlin:**

```kotlin
package com.didan.android.databinding

import android.content.Context
import android.view.View
import android.widget.Toast

class VehicleClickHandlers(var context: Context) {

    /**
     * Ham xu ly su kien click cho nut button su dung Data Binding
     * (them thuoc tinh android:onClick="@{data::displayToastMessage}" trong tag Button cua layout)
     * @param view View duoc click (o day la Button trong layout)
     */
    fun displayToastMessage(view: View): Unit {
        Toast.makeText(
            context,
            "You Clicked the Button!",
            Toast.LENGTH_SHORT
        ).show()
    }
}
```

**XML:**

```xml
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="data"
            type="com.didan.android.databinding.VehicleClickHandlers" />
        <variable
            name="vehicleName"
            type="String" />
    </data>

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Click me"
        android:onClick="@{data::displayToastMessage}" />
</layout>
```

### Truyen tham so vao ham click

Neu muon truyen them du lieu (vi du: ten xe), ban co the khai bao them tham so trong ham va goi trong XML.

**Kotlin:**

```kotlin
class VehicleClickHandlers(var context: Context) {
    fun displayToastMessage(view: View, name: String) {
        Toast.makeText(context, "Clicked: $name", Toast.LENGTH_SHORT).show()
    }
}
```

**XML:**

```xml
<Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Click me"
    android:onClick="@{(v) -> data.displayToastMessage(v, vehicleName)}" />
```

**Gan handler trong Activity/Fragment:**

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.data = VehicleClickHandlers(this)
    }
}
```

## Two-Way Data Binding

Two-way data binding cho phép dữ liệu cập nhật qua lại giữa UI và đối tượng dữ liệu. Khi người dùng nhập dữ liệu trên giao diện, đối tượng dữ liệu sẽ được cập nhật tự động, và ngược lại.

### Ví dụ với EditText

```xml
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="user"
            type="com.example.app.User" />
    </data>

    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@={user.name}" />
</layout>
```

Điểm khác biệt là dùng `@={...}` thay vì `@{...}`. Dấu `=` giúp đồng bộ dữ liệu hai chiều.

### Lưu ý khi dùng two-way binding

- Cần dùng Observable (ví dụ: `ObservableField`, `LiveData`) hoặc các thuộc tính có thể quan sát.
- Nếu dữ liệu không tự cập nhật, hãy kiểm tra xem model có hỗ trợ thông báo thay đổi hay không.

### Sơ đồ luồng dữ liệu (two-way)

Sơ đồ đơn giản giúp bạn hình dung cách dữ liệu đi qua lại:

```
Nguoi dung nhap -> View (EditText)
        |                 |
        v                 |
  @={...} binding --------+
        |
        v
  Model / ViewModel
        |
        v
  UI tu dong cap nhat
```

## Binding Adapter (Tuy chinh hien thi)

Binding Adapter cho phép bạn tạo thuộc tính XML tuỳ biến và xử lý chúng bằng Kotlin, giúp layout gọn hơn và tái sử dụng logic hiển thị.

### Ví dụ: Thuộc tính isVisible

**Kotlin:**

```kotlin
object ViewBindingAdapters {
    @JvmStatic
    @BindingAdapter("isVisible")
    fun bindIsVisible(view: View, visible: Boolean) {
        view.visibility = if (visible) View.VISIBLE else View.GONE
    }
}
```

**XML:**

```xml
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Dang tai..."
    app:isVisible="@{viewModel.loading}" />
```

Lưu ý: Với Binding Adapter, bạn cần khai báo namespace `app` trong layout.

### Binding Adapter nang cao

Duoi day la mot so vi du thuong dung giup layout gon hon va de tai su dung:

#### 1) Dinh dang so tien

**Kotlin:**

```kotlin
object TextBindingAdapters {
    @JvmStatic
    @BindingAdapter("currencyText")
    fun bindCurrencyText(view: TextView, amount: Long?) {
        val value = amount ?: 0L
        val formatted = NumberFormat.getCurrencyInstance().format(value)
        view.text = formatted
    }
}
```

**XML:**

```xml
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:currencyText="@{viewModel.totalPrice}" />
```

#### 2) Dinh dang ngay thang

**Kotlin:**

```kotlin
object DateBindingAdapters {
    private val formatter = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    @JvmStatic
    @BindingAdapter("dateText")
    fun bindDateText(view: TextView, millis: Long?) {
        val value = millis ?: 0L
        view.text = formatter.format(Date(value))
    }
}
```

**XML:**

```xml
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:dateText="@{viewModel.createdAt}" />
```

#### 3) Tai anh voi Coil

**Kotlin:**

```kotlin
object ImageBindingAdapters {
    @JvmStatic
    @BindingAdapter("imageUrl")
    fun bindImageUrl(view: ImageView, url: String?) {
        view.load(url) {
            placeholder(R.drawable.ic_avatar_placeholder)
            error(R.drawable.ic_avatar_error)
        }
    }
}
```

**XML:**

```xml
<ImageView
    android:layout_width="72dp"
    android:layout_height="72dp"
    app:imageUrl="@{viewModel.avatarUrl}" />
```

Ghi chu: Vi du tren su dung Coil (`io.coil-kt:coil`) va 2 drawable placeholder/error. Ban co the thay bang Glide hoac Picasso neu du an da su dung san.

### Luu y hieu nang khi viet Binding Adapter

- Tranh tao doi tuong moi qua thuong xuyen trong adapter (vi du: `SimpleDateFormat`). Nen khai bao dung chung hoac cache.
- Neu binding co the duoc goi lai nhieu lan, hay so sanh gia tri cu va moi de tranh cap nhat UI khong can thiet.
- Uu tien truyen `@BindingAdapter` cac gia tri da duoc xu ly san (vd: chuoi da format), neu logic format phuc tap.
- Với anh, nen can nhac su dung `placeholder`/`error` va dung kich thuoc co dinh de tranh re-layout nhieu lan.

## Data Binding voi RecyclerView

Data Binding giúp item layout gọn hơn và adapter dễ đọc hơn.

### 1) Item layout

```xml
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="item"
            type="com.example.app.User" />
    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="12dp">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{item.name}" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{item.email}" />
    </LinearLayout>
</layout>
```

### 2) Adapter su dung binding

```kotlin
class UserAdapter(
    private val items: List<User>
) : RecyclerView.Adapter<UserAdapter.ViewHolder>() {

    class ViewHolder(val binding: ItemUserBinding) :
        RecyclerView.ViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        val binding = ItemUserBinding.inflate(inflater, parent, false)
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.binding.item = items[position]
    }

    override fun getItemCount(): Int = items.size
}
```

Với cách này, bạn không cần gọi `findViewById()` trong adapter.

## Ket hop Data Binding voi ViewModel va LiveData

Data Binding phoi hop voi MVVM giup UI tu dong cap nhat khi du lieu thay doi.

### 1) ViewModel

```kotlin
class ProfileViewModel : ViewModel() {
    val name = MutableLiveData("Nguyen Van A")
    val loading = MutableLiveData(false)
}
```

### 2) Layout su dung LiveData

```xml
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <data>
        <variable
            name="viewModel"
            type="com.example.app.ProfileViewModel" />
    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{viewModel.name}" />

        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@={viewModel.name}" />

        <ProgressBar
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:isVisible="@{viewModel.loading}" />
    </LinearLayout>
</layout>
```

### 3) Gan ViewModel va lifecycleOwner

```kotlin
class ProfileFragment : Fragment(R.layout.fragment_profile) {
    private val viewModel: ProfileViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val binding = FragmentProfileBinding.bind(view)
        binding.viewModel = viewModel
        binding.lifecycleOwner = viewLifecycleOwner
    }
}
```

Lưu ý: `lifecycleOwner` là bắt buộc nếu bạn muốn LiveData tự động cập nhật UI.

---

Tài liệu này giúp bạn nắm được những phần cơ bản nhất của Data Binding. Khi đã quen, bạn có thể tìm hiểu thêm về include layout, view stub với binding, hoặc viết binding adapter nâng cao.
