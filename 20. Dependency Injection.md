# 20. Dependency Injection (DI) trong Android với Hilt

Tài liệu này giải thích Dependency Injection (DI) theo cách “người mới bắt đầu” và hướng dẫn cách dùng **Hilt** (thư viện DI chính thức dựa trên Dagger) trong Android.

## Dependency Injection with Hilt in Android

### Mục lục

- [What is Dependency Injection?](#what-is-dependency-injection)
- [Without Dependency Injection](#without-dependency-injection)
- [With Dependency Injection](#with-dependency-injection)
- [Adding Hilt to Our Android Apps](#adding-hilt-to-our-android-apps)
- [Constructor Injection using Hilt](#constructor-injection-using-hilt)
- [Hilt Module](#hilt-module)
- [App Module](#app-module)
- [Dependency Injection with Hilt](#dependency-injection-with-hilt)
- [Field Injection](#field-injection)
- [Method Injection](#method-injection)
- [Hilt Annotations](#hilt-annotations)

---

### What is Dependency Injection?

**Dependency (phụ thuộc)** là những đối tượng mà một class cần để làm việc.

Ví dụ: `JournalRepository` cần `FirebaseFirestore`, `FirebaseAuth` để đọc/ghi dữ liệu. Khi đó `FirebaseFirestore` và `FirebaseAuth` là dependency của `JournalRepository`.

**Dependency Injection (DI)** là kỹ thuật **cung cấp (inject) dependency từ bên ngoài** thay vì để class tự tạo ra dependency bên trong nó.

### Vì sao DI quan trọng?

DI giúp:

- **Giảm kết dính (coupling)**: class không “dính chặt” vào cách tạo dependency cụ thể.
- **Dễ test**: có thể thay dependency thật bằng fake/mock.
- **Dễ mở rộng/bảo trì**: thay implementation (VD: đổi từ Firestore sang REST API) ít phải sửa code.
- **Quản lý vòng đời & phạm vi (scope)** rõ ràng: singleton, theo Activity, theo ViewModel, v.v.

### DI khác gì “Service Locator”?

- **DI**: dependency được **đưa vào** class (constructor/field/method).
- **Service Locator**: class **đi tìm** dependency từ một “kho” chung (thường dễ lạm dụng, khó kiểm soát phụ thuộc).

---

### Without Dependency Injection

Ví dụ (cố tình làm “không DI”):

```kotlin
class JournalRepository {
    private val firestore = com.google.firebase.firestore.FirebaseFirestore.getInstance()
    private val auth = com.google.firebase.auth.FirebaseAuth.getInstance()

    fun addEntry(title: String, content: String) {
        val uid = auth.currentUser?.uid ?: return
        val doc = mapOf("title" to title, "content" to content, "uid" to uid)
        firestore.collection("entries").add(doc)
    }
}
```

### Vấn đề của cách làm này

1. **Khó test**
   - Bạn không thể “bơm” một `FakeFirestore` vào `JournalRepository`.
   - Unit test bị phụ thuộc vào Firebase thật → test chậm, khó chạy CI.

2. **Coupling cao**
   - Repository bị khóa chặt vào Firebase: muốn đổi sang một nguồn dữ liệu khác → sửa rất nhiều chỗ.

3. **Khó quản lý vòng đời**
   - Bạn không biết dependency được tạo lúc nào, dùng chung hay không, có bị tạo lại nhiều lần không.

---

### With Dependency Injection

Tư tưởng DI: `JournalRepository` **không tự tạo** `FirebaseFirestore`/`FirebaseAuth`, mà nhận chúng từ bên ngoài:

```kotlin
class JournalRepository(
    private val firestore: com.google.firebase.firestore.FirebaseFirestore,
    private val auth: com.google.firebase.auth.FirebaseAuth
) {
    fun addEntry(title: String, content: String) {
        val uid = auth.currentUser?.uid ?: return
        val doc = mapOf("title" to title, "content" to content, "uid" to uid)
        firestore.collection("entries").add(doc)
    }
}
```

Lúc này, nơi “bên ngoài” sẽ chịu trách nhiệm tạo và cung cấp dependency. Với Android, việc “cung cấp” này thường do một DI framework như **Hilt** đảm nhiệm.

### Lợi ích thấy ngay

- Có thể cung cấp `FakeAuth`, `FakeFirestore` khi test.
- Dễ thay đổi nguồn dữ liệu.
- Giảm code khởi tạo lặp lại ở nhiều nơi.

---

### Adding Hilt to Our Android Apps

### 1) Thêm plugin + dependency

> Dự án của bạn đang dùng **Gradle Kotlin DSL** và **Version Catalog** (`gradle/libs.versions.toml`). Bên dưới là 2 cách: dùng Version Catalog (khuyến nghị) hoặc khai báo trực tiếp.

#### Cách A — Dùng Version Catalog (khuyến nghị)

1) Trong `gradle/libs.versions.toml`, thêm (ví dụ):

```toml
[versions]
hilt = "<hilt-version>"

[libraries]
hilt-android = { group = "com.google.dagger", name = "hilt-android", version.ref = "hilt" }
hilt-compiler = { group = "com.google.dagger", name = "hilt-compiler", version.ref = "hilt" }

[plugins]
hilt-android = { id = "com.google.dagger.hilt.android", version.ref = "hilt" }
```

2) Trong `build.gradle.kts` (project-level), bật plugin (apply false):

```kotlin
plugins {
    alias(libs.plugins.hilt.android) apply false
}
```

3) Trong `app/build.gradle.kts`:

```kotlin
plugins {
    alias(libs.plugins.hilt.android)
    kotlin("kapt")
}

dependencies {
    implementation(libs.hilt.android)
    kapt(libs.hilt.compiler)
}
```

#### Cách B — Khai báo trực tiếp (dễ hiểu cho người mới)

Trong `build.gradle.kts` (project-level):

```kotlin
plugins {
    id("com.google.dagger.hilt.android") version "<hilt-version>" apply false
}
```

Trong `app/build.gradle.kts`:

```kotlin
plugins {
    id("com.google.dagger.hilt.android")
    kotlin("kapt")
}

dependencies {
    implementation("com.google.dagger:hilt-android:<hilt-version>")
    kapt("com.google.dagger:hilt-compiler:<hilt-version>")
}
```

> Ghi chú:
> - Hilt cần compiler (thường là `kapt`) để sinh code.
> - Hãy thay `<hilt-version>` bằng phiên bản phù hợp với dự án của bạn.

### 2) Tạo `Application` và gắn `@HiltAndroidApp`

Tạo class `Application`:

```kotlin
@dagger.hilt.android.HiltAndroidApp
class JournalApplication : android.app.Application()
```

Khai báo trong `AndroidManifest.xml`:

```xml
<application
    android:name=".JournalApplication"
    ... >
</application>
```

### 3) Đánh dấu nơi cần inject bằng `@AndroidEntryPoint`

Với Activity/Fragment/Service/BroadcastReceiver… bạn muốn dùng injected dependency:

```kotlin
@dagger.hilt.android.AndroidEntryPoint
class MainActivity : androidx.appcompat.app.AppCompatActivity() {
    // ...
}
```

### 4) (Tuỳ chọn) Dùng Hilt với ViewModel

```kotlin
@dagger.hilt.android.lifecycle.HiltViewModel
class JournalViewModel @javax.inject.Inject constructor(
    private val repository: JournalRepository
) : androidx.lifecycle.ViewModel()
```

Trong Activity/Fragment:

```kotlin
private val viewModel: JournalViewModel by androidx.activity.viewModels()
// hoặc: by androidx.fragment.app.viewModels()
```

---

### Constructor Injection using Hilt

**Constructor Injection** là cách phổ biến và “sạch” nhất: dependency đi vào qua constructor.

### Khi nào dùng được?

Bạn dùng constructor injection khi:

- Class là của bạn (không phải class từ thư viện thứ ba).
- Bạn có thể thêm `@Inject` vào constructor.

Ví dụ một use case:

```kotlin
class AddJournalEntryUseCase @javax.inject.Inject constructor(
    private val repository: JournalRepository
) {
    operator fun invoke(title: String, content: String) {
        repository.addEntry(title, content)
    }
}
```

Ví dụ ViewModel nhận use case:

```kotlin
@dagger.hilt.android.lifecycle.HiltViewModel
class JournalViewModel @javax.inject.Inject constructor(
    private val addEntry: AddJournalEntryUseCase
) : androidx.lifecycle.ViewModel()
```

### Tại sao constructor injection tốt?

- Rõ ràng: nhìn constructor là biết class cần gì.
- Dễ test: đưa fake vào constructor.
- Hạn chế “nullable/lateinit” so với field injection.

---

### Hilt Module

Hilt có thể tự tạo một số class chỉ bằng `@Inject constructor(...)`. Tuy nhiên có những trường hợp **Hilt không tự tạo được**, bạn phải dùng **Module** để “dạy” Hilt cách cung cấp dependency.

### Khi nào cần Module?

1. **Interface / abstract type**
   - `JournalRepository` là interface → cần map tới `FirebaseJournalRepository`.
2. **Class từ thư viện bên ngoài**
   - Ví dụ: `FirebaseFirestore`, `FirebaseAuth`, `OkHttpClient`, `Retrofit`, v.v.
3. **Cần cấu hình khi tạo**
   - Ví dụ: `Retrofit.Builder().baseUrl(...).build()`
4. **Cần nhiều phiên bản của cùng một kiểu**
   - Ví dụ: 2 `OkHttpClient` khác cấu hình → cần qualifier.

### Cấu trúc một Module cơ bản

```kotlin
@dagger.Module
@dagger.hilt.InstallIn(dagger.hilt.components.SingletonComponent::class)
object NetworkModule {

    @dagger.Provides
    @javax.inject.Singleton
    fun provideBaseUrl(): String = "https://example.com/"
}
```

Giải thích nhanh:

- `@Module`: đánh dấu đây là nơi khai báo cách cung cấp dependency.
- `@InstallIn(...)`: module sẽ “gắn” vào component nào (tức scope/vòng đời nào).
- `@Provides`: đây là hàm tạo dependency.
- `@Singleton` (scope): dùng chung 1 instance trong `SingletonComponent`.

---

### App Module

Phần này minh hoạ một “App Module” thường gặp để cung cấp các dependency cấp ứng dụng (Firebase, Repository, Dispatcher…).

### 1) Cung cấp Firebase instances (third-party)

```kotlin
@dagger.Module
@dagger.hilt.InstallIn(dagger.hilt.components.SingletonComponent::class)
object AppModule {

    @dagger.Provides
    @javax.inject.Singleton
    fun provideFirebaseAuth(): com.google.firebase.auth.FirebaseAuth =
        com.google.firebase.auth.FirebaseAuth.getInstance()

    @dagger.Provides
    @javax.inject.Singleton
    fun provideFirestore(): com.google.firebase.firestore.FirebaseFirestore =
        com.google.firebase.firestore.FirebaseFirestore.getInstance()

    @dagger.Provides
    @javax.inject.Singleton
    fun provideStorage(): com.google.firebase.storage.FirebaseStorage =
        com.google.firebase.storage.FirebaseStorage.getInstance()
}
```

### 2) Bind interface → implementation

Giả sử bạn thiết kế repository theo hướng “tách interface”:

```kotlin
interface JournalRepository {
    fun addEntry(title: String, content: String)
}

class FirebaseJournalRepository @javax.inject.Inject constructor(
    private val firestore: com.google.firebase.firestore.FirebaseFirestore,
    private val auth: com.google.firebase.auth.FirebaseAuth
) : JournalRepository {
    override fun addEntry(title: String, content: String) {
        val uid = auth.currentUser?.uid ?: return
        val doc = mapOf("title" to title, "content" to content, "uid" to uid)
        firestore.collection("entries").add(doc)
    }
}
```

Bạn có 2 cách để “nói” cho Hilt biết `JournalRepository` dùng implementation nào:

#### Cách A — `@Binds` (khuyến nghị cho interface)

```kotlin
@dagger.Module
@dagger.hilt.InstallIn(dagger.hilt.components.SingletonComponent::class)
abstract class RepositoryModule {

    @dagger.Binds
    @javax.inject.Singleton
    abstract fun bindJournalRepository(
        impl: FirebaseJournalRepository
    ): JournalRepository
}
```

#### Cách B — `@Provides` (linh hoạt khi cần logic tạo)

```kotlin
@dagger.Module
@dagger.hilt.InstallIn(dagger.hilt.components.SingletonComponent::class)
object RepositoryModule {

    @dagger.Provides
    @javax.inject.Singleton
    fun provideJournalRepository(
        firestore: com.google.firebase.firestore.FirebaseFirestore,
        auth: com.google.firebase.auth.FirebaseAuth
    ): JournalRepository = FirebaseJournalRepository(firestore, auth)
}
```

### 3) Qualifier (khi có nhiều dependency cùng kiểu)

Ví dụ: 2 chuỗi `String` đều có thể là dependency (baseUrl, apiKey). Khi đó bạn nên dùng qualifier:

```kotlin
@javax.inject.Qualifier
@kotlin.annotation.Retention(AnnotationRetention.BINARY)
annotation class ApiKey

@dagger.Module
@dagger.hilt.InstallIn(dagger.hilt.components.SingletonComponent::class)
object ConfigModule {
    @dagger.Provides fun provideBaseUrl(): String = "https://example.com/"
    @dagger.Provides @ApiKey fun provideApiKey(): String = "secret"
}
```

Inject:

```kotlin
class SomeClient @javax.inject.Inject constructor(
    private val baseUrl: String,
    @ApiKey private val apiKey: String
)
```

---

### Dependency Injection with Hilt

Phần này ghép lại thành một luồng DI hoàn chỉnh theo kiểu “từ ngoài vào trong”:

1) `AppModule` cung cấp Firebase và bind repository  
2) ViewModel nhận `JournalRepository` qua constructor injection  
3) Activity/Fragment tạo ViewModel và gọi hàm

Ví dụ ViewModel:

```kotlin
@dagger.hilt.android.lifecycle.HiltViewModel
class JournalViewModel @javax.inject.Inject constructor(
    private val repository: JournalRepository
) : androidx.lifecycle.ViewModel() {

    fun add(title: String, content: String) {
        repository.addEntry(title, content)
    }
}
```

Ví dụ Activity:

```kotlin
@dagger.hilt.android.AndroidEntryPoint
class MainActivity : androidx.appcompat.app.AppCompatActivity() {

    private val viewModel: JournalViewModel by androidx.activity.viewModels()

    override fun onCreate(savedInstanceState: android.os.Bundle?) {
        super.onCreate(savedInstanceState)
        // setContentView(...)

        viewModel.add("Hôm nay", "Bắt đầu học DI với Hilt")
    }
}
```

---

### Field Injection

**Field Injection** là inject trực tiếp vào thuộc tính (field/property). Cách này hay dùng trong Android framework types (Activity/Fragment) khi bạn không kiểm soát constructor.

Ví dụ:

```kotlin
@dagger.hilt.android.AndroidEntryPoint
class MainActivity : androidx.appcompat.app.AppCompatActivity() {

    @javax.inject.Inject
    lateinit var auth: com.google.firebase.auth.FirebaseAuth

    override fun onCreate(savedInstanceState: android.os.Bundle?) {
        super.onCreate(savedInstanceState)
        // auth đã sẵn sàng sau khi Hilt inject
    }
}
```

### Lưu ý quan trọng

- Chỉ dùng field injection khi thật sự cần (Activity/Fragment/Service…).
- Với class bạn tự tạo được, ưu tiên **constructor injection** để dễ test và rõ dependency.

---

### Method Injection

**Method Injection** là inject thông qua một phương thức (Hilt/Dagger sẽ gọi phương thức đó để truyền dependency).

Ví dụ:

```kotlin
class AnalyticsTracker @javax.inject.Inject constructor()

class SomeScreenController @javax.inject.Inject constructor() {
    private lateinit var analytics: AnalyticsTracker

    @javax.inject.Inject
    fun setAnalytics(tracker: AnalyticsTracker) {
        analytics = tracker
    }
}
```

### Khi nào nên dùng?

- Khi bạn cần inject sau khi object đã được tạo (trường hợp đặc biệt).
- Khi muốn inject “tuỳ chọn” hoặc tách một phần cấu hình.

### Khi nào không nên lạm dụng?

- Khi có thể dùng constructor injection: **constructor injection luôn rõ ràng và an toàn hơn**.

---

### Hilt Annotations

Danh sách annotation quan trọng (dùng thường xuyên):

### Annotation nền tảng

- `@HiltAndroidApp`: đặt trên `Application` để khởi tạo Hilt cho toàn app.
- `@AndroidEntryPoint`: đặt trên Android class (Activity/Fragment/Service/Receiver…) để Hilt inject vào đó.
- `@Inject`: đánh dấu constructor/field/method cần được inject.

### Dành cho ViewModel

- `@HiltViewModel`: đánh dấu ViewModel để Hilt tạo và quản lý dependency.

### Dành cho Module

- `@Module`: khai báo một Hilt module.
- `@InstallIn(...)`: chỉ định module thuộc component nào (`SingletonComponent`, `ActivityComponent`, …).
- `@Provides`: cung cấp dependency bằng một hàm (thường dùng với thư viện ngoài hoặc cần logic tạo).
- `@Binds`: bind interface → implementation (chỉ dùng trong abstract module).

### Scope (phạm vi vòng đời)

> Scope giúp quyết định “dùng chung 1 instance hay tạo mới”, và sống được bao lâu.

- `@Singleton`: dùng 1 instance cho toàn app (trong `SingletonComponent`).
- Các scope thường gặp khác (tuỳ nhu cầu): `@ActivityScoped`, `@FragmentScoped`, `@ViewModelScoped`, v.v.

### Qualifier (phân biệt cùng kiểu)

- `@Named("...")`: qualifier có sẵn, dùng khi muốn phân biệt theo tên.
- `@Qualifier` + annotation tự định nghĩa: mạnh hơn và rõ ràng hơn khi dự án lớn.

### EntryPoint (trường hợp đặc biệt)

- `@EntryPoint`: dùng khi bạn cần lấy dependency ở nơi Hilt không thể inject trực tiếp (không khuyến khích nếu không cần).

---

### Tổng kết nhanh

- DI là cách cung cấp dependency từ bên ngoài để giảm coupling và dễ test.
- Hilt giúp bạn làm DI “chuẩn Android” với ít boilerplate.
- Ưu tiên **constructor injection**, dùng **field injection** cho Activity/Fragment khi cần.
- Dùng **module** cho interface/third-party types/cấu hình phức tạp.
