# 20. Dependency Injection (DI) với Hilt trong Android (EcomerceApp)

Tài liệu này giải thích DI theo hướng “người mới bắt đầu”, đồng thời dùng **chính code trong project** `EcomerceApp` để minh hoạ cách cấu hình và dùng **Hilt** (DI framework chính thức của Android dựa trên Dagger).

## Mục tiêu sau khi đọc xong

- Hiểu “dependency”, “injection”, “scope” là gì và vì sao nên dùng DI.
- Biết cấu hình Hilt cho project dùng **Gradle Kotlin DSL** + **Version Catalog** + **KSP** (đúng như project hiện tại).
- Hiểu luồng DI trong project: `FirebaseFirestore` + `Room (CartDatabase/CartDao)` → `Repository` → `MyViewModel` → `Activity`.
- Nắm các kỹ thuật “nâng cao” hay gặp: `@Binds` (interface), `@Qualifier`, inject `CoroutineDispatcher`, và gợi ý tổ chức module.

---

## Mục lục

- [1. DI là gì?](#1-di-la-gi)
- [2. Vì sao DI quan trọng?](#2-vi-sao-di-quan-trong)
- [3. Hilt là gì? (Hilt vs Dagger)](#3-hilt-la-gi)
- [4. Cấu hình Hilt trong project này (Kotlin DSL + Version Catalog + KSP)](#4-cau-hinh-hilt-trong-project)
- [5. Kích hoạt Hilt bằng `@HiltAndroidApp`](#5-kich-hoat-hilt)
- [6. Module trong project: `FirebaseModule` và `RoomModule`](#6-module-trong-project)
- [7. Constructor injection: `Repository` và `MyViewModel`](#7-constructor-injection)
- [8. Inject vào Android framework classes: `@AndroidEntryPoint` + `by viewModels()`](#8-androidentrypoint-by-viewmodels)
- [9. Scopes và vòng đời trong Hilt (hiểu để tránh bug)](#9-scopes-va-vong-doi)
- [10. Nâng cao: tách interface + `@Binds`](#10-nang-cao-interface-binds)
- [11. Nâng cao: `@Qualifier` và inject `Dispatcher`](#11-nang-cao-qualifier-dispatcher)
- [12. Nâng cao: viết test với Hilt (gợi ý)](#12-nang-cao-test-hilt)
- [13. Lỗi thường gặp và cách sửa nhanh](#13-loi-thuong-gap)
- [14. Tổng kết](#14-tong-ket)

---

<a id="1-di-la-gi"></a>
## 1. DI là gì?

**Dependency (phụ thuộc)** là những đối tượng mà một class cần để hoạt động.

Ví dụ trong project:

- `Repository` cần `FirebaseFirestore` để đọc/ghi dữ liệu trên cloud.
- `Repository` cần `CartDao` để thao tác giỏ hàng bằng Room.

**Dependency Injection (DI)** là kỹ thuật *đưa (inject) dependency từ bên ngoài vào class*, thay vì để class tự tạo dependency bên trong.

Nói nôm na:

- Không DI: `Repository` tự gọi `FirebaseFirestore.getInstance()` và tự tạo database → coupling cao.
- Có DI: nơi khác (Hilt) tạo `FirebaseFirestore`, `CartDao` rồi “bơm” vào `Repository`.

---

<a id="2-vi-sao-di-quan-trong"></a>
## 2. Vì sao DI quan trọng?

DI giúp:

- **Giảm coupling**: class ít phụ thuộc vào “cách tạo” dependency.
- **Dễ test**: thay dependency thật bằng fake/mock.
- **Dễ bảo trì/mở rộng**: đổi Firestore sang API khác ít “đụng” code.
- **Quản lý vòng đời (scope)**: biết dependency sống bao lâu, có dùng chung không.

### DI khác gì “Service Locator”?

- **DI**: dependency được đưa vào (constructor/field/method).
- **Service Locator**: class tự đi lấy dependency từ “kho chung” → dễ che giấu phụ thuộc, khó test.

---

<a id="3-hilt-la-gi"></a>
## 3. Hilt là gì? (Hilt vs Dagger)

- **Dagger**: DI framework mức thấp, mạnh nhưng cấu hình nhiều hơn.
- **Hilt**: lớp “wrapper” cho Dagger, tối ưu cho Android:
  - Tạo sẵn các component theo vòng đời Android.
  - Ít boilerplate hơn.
  - Tích hợp tốt với `ViewModel`, `Activity`, `Fragment`, `Service`,…

Bạn vẫn dùng các annotation của Dagger (`@Module`, `@Provides`, `@Binds`, `@Inject`), nhưng Hilt giúp “cắm” vào Android đúng cách.

---

<a id="4-cau-hinh-hilt-trong-project"></a>
## 4. Cấu hình Hilt trong project này (Kotlin DSL + Version Catalog + KSP)

Project của bạn hiện đang dùng:

- Gradle Kotlin DSL (`build.gradle.kts`)
- Version Catalog (`gradle/libs.versions.toml`)
- KSP (`com.google.devtools.ksp`) để chạy compiler (thay vì `kapt`)
- Hilt version `2.57.1`

### 4.1. Khai báo version và dependency trong `gradle/libs.versions.toml`

Trong project hiện tại đã có:

```toml
[versions]
hiltAndroid = "2.57.1"
hiltAndroidCompiler = "2.57.1"

[libraries]
hilt-android = { module = "com.google.dagger:hilt-android", version.ref = "hiltAndroid" }
hilt-android-compiler = { module = "com.google.dagger:hilt-android-compiler", version.ref = "hiltAndroidCompiler" }
```

### 4.2. Bật plugin Hilt ở project-level: `build.gradle.kts`

Project đang dùng:

```kotlin
plugins {
    id("com.google.dagger.hilt.android") version "2.57.1" apply false
}
```

Ý nghĩa của `apply false`:

- Chỉ “khai báo sẵn” plugin ở root.
- Module nào cần thì mới `apply` plugin đó (ví dụ `app/`).

### 4.3. Cấu hình module app: `app/build.gradle.kts`

Project đang dùng **KSP** cho Hilt compiler:

```kotlin
plugins {
    id("com.google.dagger.hilt.android")
    id("com.google.devtools.ksp")
}

dependencies {
    implementation(libs.hilt.android)
    ksp(libs.hilt.android.compiler)
}
```

> Ghi chú nhanh (cho người mới):
>
> - `implementation(libs.hilt.android)` là thư viện runtime.
> - `ksp(libs.hilt.android.compiler)` là “compiler” để sinh code (thay cho `kapt`).
> - Nếu bạn dùng `kapt` thay vì `ksp` thì cấu hình sẽ khác (cần `kotlin("kapt")` + `kapt(...)`).

---

<a id="5-kich-hoat-hilt"></a>
## 5. Kích hoạt Hilt bằng `@HiltAndroidApp`

Hilt cần một `Application` để tạo “gốc” của dependency graph.

Project hiện tại có:

```kotlin
// app/src/main/java/.../di/EcommerceApp.kt
@HiltAndroidApp
class EcommerceApp : Application()
```

Và đã khai báo trong manifest:

```xml
<application
    android:name=".di.EcommerceApp"
    ... />
```

Nếu thiếu bước này, bạn sẽ gặp lỗi kiểu:

- “Hilt Android App is missing…”
- “Expected @HiltAndroidApp…”

---

<a id="6-module-trong-project"></a>
## 6. Module trong project: `FirebaseModule` và `RoomModule`

Hilt có thể tự tạo dependency khi:

- Class của bạn có `@Inject constructor(...)`

Nhưng có những trường hợp Hilt **không tự tạo được**, ví dụ:

- Class từ thư viện ngoài (`FirebaseFirestore`, Retrofit, OkHttp,…)
- Cần `Context` hoặc cấu hình phức tạp khi tạo

Lúc này ta dùng **Module**.

### 6.1. `FirebaseModule`: cung cấp `FirebaseFirestore`

Trong project:

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object FirebaseModule {

    @Provides
    @Singleton
    fun provideFirestore(): FirebaseFirestore = FirebaseFirestore.getInstance()
}
```

Giải thích:

- `@Module`: báo cho Hilt đây là nơi “dạy” cách tạo dependency.
- `@InstallIn(SingletonComponent::class)`: dependency trong module này sống ở scope “toàn app”.
- `@Provides`: hàm tạo dependency.
- `@Singleton`: dùng chung 1 instance trong toàn ứng dụng.

### 6.2. `RoomModule`: cung cấp `CartDatabase` và `CartDao`

Trong project:

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object RoomModule {

    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): CartDatabase {
        return CartDatabase.getDatabase(context)
    }

    @Provides
    @Singleton
    fun provideDao(database: CartDatabase): CartDao {
        return database.cartDao()
    }
}
```

Điểm rất quan trọng cho người mới:

- `@ApplicationContext` giúp Hilt biết phải inject “Context cấp ứng dụng”, tránh leak Activity.
- `CartDao` được “tách” ra từ `CartDatabase` → Hilt sẽ tự hiểu dependency chain:
  - Muốn có `CartDao` → cần `CartDatabase`
  - Muốn có `CartDatabase` → cần `Context`

> Gợi ý nâng cao (mang tính “đẹp chuẩn Hilt”):
>
> Hiện tại `CartDatabase` đang dùng pattern singleton thủ công (`INSTANCE` + `getDatabase()`).
> Với Hilt, bạn có thể bỏ singleton thủ công và để Hilt quản lý `@Singleton` hoàn toàn (thường viết `Room.databaseBuilder(...)` ngay trong module).

---

<a id="7-constructor-injection"></a>
## 7. Constructor injection: `Repository` và `MyViewModel`

Đây là phần quan trọng nhất: **từ module → class → ViewModel**.

### 7.1. `Repository` nhận dependency qua constructor

Trong project:

```kotlin
class Repository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val cartDao: CartDao
)
```

Tại sao Hilt biết cách tạo `Repository`?

- `Repository` có `@Inject constructor(...)` → Hilt có thể tự tạo.
- Mọi tham số trong constructor đều có “binding”:
  - `FirebaseFirestore` được cung cấp bởi `FirebaseModule.provideFirestore()`
  - `CartDao` được cung cấp bởi `RoomModule.provideDao()`

### 7.2. `MyViewModel` nhận `Repository` qua constructor + `@HiltViewModel`

Trong project:

```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val repository: Repository
) : ViewModel()
```

Điểm cần nhớ:

- `@HiltViewModel` nói với Hilt: “đây là ViewModel, hãy tạo theo lifecycle ViewModel”.
- `@Inject constructor(...)` nói với Hilt: “các dependency của ViewModel nằm ở constructor”.

---

<a id="8-androidentrypoint-by-viewmodels"></a>
## 8. Inject vào Android framework classes: `@AndroidEntryPoint` + `by viewModels()`

Bạn không thể tự thêm constructor cho `Activity`/`Fragment`, nên Hilt cần “hook” vào vòng đời bằng `@AndroidEntryPoint`.

Trong project, các Activity đều có:

```kotlin
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()
}
```

Luồng chạy thực tế:

1) `@HiltAndroidApp` tạo container cho toàn app.
2) `@AndroidEntryPoint` tạo “sub-container” phù hợp với `Activity`.
3) `by viewModels()` + `@HiltViewModel` khiến Hilt tạo `MyViewModel`.
4) Để tạo `MyViewModel`, Hilt tạo `Repository`.
5) Để tạo `Repository`, Hilt lấy `FirebaseFirestore` + `CartDao` từ các module.

> Bạn có thể inject trực tiếp dependency vào Activity bằng field injection (ít dùng hơn):
>
> ```kotlin
> @AndroidEntryPoint
> class MainActivity : AppCompatActivity() {
>     @Inject lateinit var firestore: FirebaseFirestore
> }
> ```
>
> Với class “thuần Kotlin” (Repository, UseCase, Mapper…), ưu tiên constructor injection vì rõ ràng và dễ test.

---

<a id="9-scopes-va-vong-doi"></a>
## 9. Scopes và vòng đời trong Hilt (hiểu để tránh bug)

### 9.1. Scope là gì?

Scope quyết định:

- Dependency có được **tái sử dụng** hay không (reuse).
- Dependency sống trong **vòng đời nào**.

Ví dụ: `@Singleton` nghĩa là trong `SingletonComponent` chỉ có 1 instance dùng chung.

### 9.2. Những component/scope bạn hay gặp

- `SingletonComponent` + `@Singleton`: sống cùng ứng dụng.
- `ActivityComponent` + `@ActivityScoped`: sống cùng Activity (mỗi Activity một instance).
- `ViewModelComponent` + `@ViewModelScoped`: sống cùng ViewModel.

Trong project hiện tại:

- `FirebaseFirestore` là `@Singleton` → dùng chung toàn app.
- `CartDatabase` và `CartDao` là `@Singleton` → dùng chung toàn app.
- `Repository` **chưa có scope** → mặc định có thể bị tạo mới khi cần (thường là mỗi ViewModel/consumer).

### 9.3. Khi nào nên scope `Repository`?

Tuỳ chiến lược thiết kế, bạn có thể:

- Giữ mặc định (không scope) nếu không sao.
- Hoặc làm rõ bằng `@Singleton` để tránh tạo mới không cần thiết:

```kotlin
@Singleton
class Repository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val cartDao: CartDao
)
```

> Lưu ý: Scope không phải lúc nào cũng “càng nhiều càng tốt”. Lạm dụng `@Singleton` có thể giữ state quá lâu hoặc khó test nếu repository có state.

---

<a id="10-nang-cao-interface-binds"></a>
## 10. Nâng cao: tách interface + `@Binds`

Trong project hiện tại, `Repository` là class cụ thể. Với project lớn, cách làm phổ biến là:

- Tạo interface (hợp đồng) cho repository.
- Tạo implementation thật (Firestore + Room).
- Dùng `@Binds` để map interface → implementation.

Lợi ích:

- Dễ test (đổi sang fake repository).
- Dễ thay data source (Firestore → REST API…).
- Giảm phụ thuộc “trực tiếp” vào chi tiết triển khai.

Ví dụ gợi ý theo project:

```kotlin
interface EcommerceRepository {
    fun fetchCategories(): MutableLiveData<List<Category>>
    fun fetchProducts(categoryName: String): MutableLiveData<List<Product>>
    suspend fun addProductToCart(product: Product)
    suspend fun getAllCartItems(): List<Product>
}

class DefaultEcommerceRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val cartDao: CartDao
) : EcommerceRepository {
    // triển khai dựa trên code hiện tại của Repository
}
```

Module bind:

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    @Singleton
    abstract fun bindEcommerceRepository(
        impl: DefaultEcommerceRepository
    ): EcommerceRepository
}
```

Khi đó ViewModel inject interface:

```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val repository: EcommerceRepository
) : ViewModel()
```

---

<a id="11-nang-cao-qualifier-dispatcher"></a>
## 11. Nâng cao: `@Qualifier` và inject `Dispatcher`

### 11.1. Vì sao cần `@Qualifier`?

Khi bạn có **nhiều dependency cùng kiểu**, Hilt không biết chọn cái nào.

Ví dụ phổ biến:

- 2 cái `String` (`baseUrl`, `apiKey`)
- 2 cái `CoroutineDispatcher` (`IO`, `Default`)

### 11.2. Ví dụ inject `CoroutineDispatcher` (rất hữu ích khi test)

Tạo qualifier:

```kotlin
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class IoDispatcher
```

Module cung cấp dispatcher:

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object CoroutinesModule {

    @Provides
    @IoDispatcher
    fun provideIoDispatcher(): CoroutineDispatcher = Dispatchers.IO
}
```

Inject vào repository:

```kotlin
class Repository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val cartDao: CartDao,
    @IoDispatcher private val io: CoroutineDispatcher
)
```

Lợi ích:

- Trong test, bạn có thể thay `Dispatchers.IO` bằng test dispatcher để chạy nhanh và determinism hơn.

---

<a id="12-nang-cao-test-hilt"></a>
## 12. Nâng cao: viết test với Hilt (gợi ý)

Nếu sau này bạn muốn viết instrumented test (androidTest) dùng Hilt, thường bạn sẽ gặp các mảnh ghép sau:

- `@HiltAndroidTest`
- `HiltAndroidRule`
- `@TestInstallIn` để thay module thật bằng module test

Ví dụ skeleton:

```kotlin
@HiltAndroidTest
class RepositoryTest {

    @get:Rule
    val hiltRule = HiltAndroidRule(this)

    @Inject lateinit var firestore: FirebaseFirestore

    @Before fun setup() {
        hiltRule.inject()
    }
}
```

> Gợi ý: Với unit test JVM thuần (test/), Hilt khó dùng trực tiếp hơn; bạn thường test logic bằng cách “new class + fake dependencies” (nhờ constructor injection).

---

<a id="13-loi-thuong-gap"></a>
## 13. Lỗi thường gặp và cách sửa nhanh

### 13.1. Quên `@HiltAndroidApp`

Triệu chứng:

- App crash khi chạy.
- Lỗi compile/runtime liên quan tới Hilt “Application”.

Cách sửa:

- Tạo `Application` có `@HiltAndroidApp`.
- Khai báo `android:name="..."` trong `AndroidManifest.xml`.

### 13.2. Quên `@AndroidEntryPoint` ở Activity/Fragment

Triệu chứng:

- ViewModel Hilt không tạo được.
- Lỗi kiểu “... must be annotated with @AndroidEntryPoint”.

Cách sửa:

- Gắn `@AndroidEntryPoint` vào Activity/Fragment đang dùng injection hoặc `by viewModels()`.

### 13.3. Quên compiler (`ksp(...)`) hoặc quên plugin KSP

Triệu chứng:

- Không sinh class Hilt (thường báo thiếu generated code).

Cách sửa (đúng theo project hiện tại):

- `plugins { id("com.google.devtools.ksp") }`
- `dependencies { ksp(libs.hilt.android.compiler) }`

### 13.4. “Tạo được nhưng dùng sai scope”

Triệu chứng:

- Dependency bị tạo mới ngoài ý muốn.
- State bị reset (nếu dependency có state).

Cách sửa:

- Thêm scope phù hợp (`@Singleton`, `@ViewModelScoped`,…).
- Đảm bảo module `@InstallIn(...)` đúng component.

---

<a id="14-tong-ket"></a>
## 14. Tổng kết

- DI là kỹ thuật đưa dependency từ ngoài vào để giảm coupling, dễ test, dễ bảo trì.
- Hilt là cách “chuẩn Android” để dùng DI, dựa trên Dagger nhưng dễ cấu hình hơn.
- Trong project này:
  - `FirebaseModule` + `RoomModule` cung cấp dependency “thư viện ngoài”.
  - `Repository` dùng constructor injection (`@Inject`).
  - `MyViewModel` dùng `@HiltViewModel` + constructor injection.
  - `Activity` dùng `@AndroidEntryPoint` + `by viewModels()`.
- Khi lên dự án lớn: cân nhắc tách interface + `@Binds`, dùng `@Qualifier`, và inject dispatcher để test tốt hơn.
