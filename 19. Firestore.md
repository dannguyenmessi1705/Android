# 19. Cloud Firestore (Android)

Cloud Firestore là cơ sở dữ liệu **NoSQL dạng document** của Firebase/Google Cloud. Nó phù hợp cho ứng dụng mobile vì:

- Dữ liệu tổ chức theo **Collection → Document → (Sub-collection)**
- Hỗ trợ **realtime** (lắng nghe thay đổi)
- Hỗ trợ **offline** (cache cục bộ và đồng bộ lại khi có mạng)

Tài liệu này viết theo **project hiện tại** (Android + Kotlin + Gradle Kotlin DSL `.kts`) và có bổ sung một số phần “nâng cao” nhưng vẫn phù hợp cho người mới bắt đầu.

## Mục lục

- [Adding Firestore](#adding-firestore)
- [Firestore Hierarchy](#firestore-hierarchy)
- [Writing Simple Data to Firestore](#writing-simple-data-to-firestore)
- [Reading Documents](#reading-documents)
- [Reading All Documents in Collection](#reading-all-documents-in-collection)
- [Update and Delete Documents](#update-and-delete-documents)
- [Compare with Firebase](#compare-with-firebase)

---

## Adding Firestore

### 1) Tạo Firebase Project và bật Firestore

1. Vào Firebase Console → tạo project.
2. Add app Android (nhập `applicationId`, ví dụ trong project là `com.didan.android.firestore`).
3. Tải file `google-services.json` và đặt vào: `app/google-services.json` (project hiện tại đã có file này).
4. Trong Firebase Console → **Build → Firestore Database** → **Create database** (chọn chế độ test để học nhanh, sau đó chuyển sang rules an toàn hơn).

### 1.1) Firestore Rules (cực quan trọng)

Nếu bạn để rules “mở” lâu, dữ liệu có thể bị đọc/ghi trái phép. Khi đã hiểu cơ bản, hãy chuyển sang rules yêu cầu đăng nhập.

Ví dụ rules tối thiểu (chỉ cho phép người dùng đã đăng nhập):

```js
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}
```

### 2) Cấu hình Gradle (đúng với project `.kts`)

Project hiện tại đang dùng:

- Google Services plugin: `com.google.gms.google-services` (root `build.gradle.kts`)
- Firebase BoM: `com.google.firebase:firebase-bom:34.8.0`
- Firestore (project có ví dụ dùng `Firebase.firestore` trong `MainActivity.kt`)

#### a) Root `build.gradle.kts`

```kotlin
plugins {
    // ...
    id("com.google.gms.google-services") version "4.4.4" apply false
}
```

#### b) Module `app/build.gradle.kts`

```kotlin
plugins {
    // ...
    id("com.google.gms.google-services")
}

dependencies {
    // Firebase BoM
    implementation(platform("com.google.firebase:firebase-bom:34.8.0"))

    // Firestore (bản thường)
    implementation("com.google.firebase:firebase-firestore")

    // (Tùy chọn) Firestore KTX để có Firebase.firestore, toObject<T>(),...
    // Nếu bạn thấy code kiểu `Firebase.firestore` bị lỗi unresolved thì hãy bật dòng này.
    // implementation("com.google.firebase:firebase-firestore-ktx")
}
```

Gợi ý:

- Khi dùng **BoM**: không ghi version cho từng thư viện Firebase.
- Nếu bạn dùng Kotlin, `firebase-firestore-ktx` giúp code ngắn gọn hơn; còn nếu không dùng KTX thì khởi tạo bằng `FirebaseFirestore.getInstance()`.

---

## Firestore Hierarchy

Firestore tổ chức dữ liệu theo dạng cây:

- **Database**
  - **Collection** (tập hợp nhiều document)
    - **Document** (1 bản ghi, dạng key-value)
      - **Fields** (các trường: string/number/boolean/map/array/timestamp/geo/...)
      - **Sub-collection** (collection con, để biểu diễn quan hệ 1-n)

Ví dụ cấu trúc thường gặp:

```
users (collection)
  ├─ user_001 (document)
  │    ├─ name: "Jack"
  │    ├─ born: 1992
  │    └─ posts (sub-collection)
  │         ├─ post_01 (document)
  │         └─ post_02 (document)
  └─ user_002 (document)
```

Quy ước đường dẫn:

- Collection: `users`
- Document: `users/user_001`
- Sub-collection: `users/user_001/posts`
- Document trong sub-collection: `users/user_001/posts/post_01`

Lưu ý quan trọng cho người mới:

- **Collection chỉ chứa document**, không chứa trực tiếp field.
- **Document có thể chứa map/array**, nhưng khi cần “danh sách lớn và query được”, hãy dùng **sub-collection** thay vì nhét tất cả vào 1 mảng khổng lồ.
- Document ID có thể:
  - Tự sinh bằng `add(...)` (dễ, an toàn tránh trùng)
  - Tự đặt bằng `document("id").set(...)` (dễ đọc/tra cứu, nhưng phải đảm bảo không trùng)

---

## Writing Simple Data to Firestore

### Khởi tạo Firestore

Với Kotlin (cách đang dùng trong project):

```kotlin
import com.google.firebase.Firebase
import com.google.firebase.firestore.firestore

val db = Firebase.firestore
```

Nếu bạn không dùng KTX:

```kotlin
import com.google.firebase.firestore.FirebaseFirestore

val db = FirebaseFirestore.getInstance()
```

### 1) Ghi document với ID tự đặt

```kotlin
val user = hashMapOf(
    "name" to "jack",
    "lname" to "reacher",
    "born" to 1992
)

db.collection("Users")
    .document("user1")
    .set(user)
    .addOnSuccessListener { /* ghi thành công */ }
    .addOnFailureListener { e -> /* xử lý lỗi */ }
```

Gợi ý: các field dùng để **lọc/sắp xếp** (ví dụ `born`) nên lưu dạng **number** (Int/Long), tránh lưu dạng string `"1992"` để query dễ và đúng kiểu dữ liệu.

`set(...)` sẽ **ghi đè toàn bộ document** nếu document đã tồn tại.

Nếu muốn “cập nhật/ghi thêm field nhưng không mất field cũ”, dùng merge:

```kotlin
import com.google.firebase.firestore.SetOptions

db.collection("Users")
    .document("user1")
    .set(mapOf("nickname" to "JR"), SetOptions.merge())
```

### 2) Ghi document với ID tự sinh (khuyến nghị cho dữ liệu tạo mới)

```kotlin
val user = mapOf("name" to "john", "born" to 1982)

db.collection("Users")
    .add(user) // Firestore tự tạo document ID
    .addOnSuccessListener { docRef ->
        val newId = docRef.id
    }
```

### (Khuyến nghị) Dùng `data class` để code sạch hơn

```kotlin
data class User(
    val name: String = "",
    val lname: String = "",
    val born: Int = 0
)

db.collection("Users")
    .document("user1")
    .set(User(name = "jack", lname = "reacher", born = 1992))
```

---

## Reading Documents

### 1) Đọc 1 document theo ID

```kotlin
db.collection("Users")
    .document("user1")
    .get()
    .addOnSuccessListener { document ->
        if (document.exists()) {
            val name = document.getString("name")
            val born = document.getLong("born")?.toInt()
        } else {
            // document không tồn tại
        }
    }
    .addOnFailureListener { e ->
        // lỗi mạng / permission / ...
    }
```

### 2) Map document sang object (dễ dùng cho app)

```kotlin
db.collection("Users")
    .document("user1")
    .get()
    .addOnSuccessListener { document ->
        if (document.exists()) {
            val user = document.toObject(User::class.java)
        }
    }
```

> Gợi ý: để `toObject(...)` hoạt động ổn định, `data class` nên có **constructor rỗng** (Kotlin default values như ví dụ ở trên là cách phổ biến).

### 3) Lắng nghe realtime (khi dữ liệu thay đổi thì UI tự cập nhật)

```kotlin
val registration = db.collection("Users")
    .document("user1")
    .addSnapshotListener { snapshot, error ->
        if (error != null) return@addSnapshotListener
        if (snapshot != null && snapshot.exists()) {
            val name = snapshot.getString("name")
        }
    }

// Khi không cần nữa (ví dụ onStop), hãy hủy listener:
// registration.remove()
```

---

## Reading All Documents in Collection

### 1) Lấy toàn bộ documents trong 1 collection

```kotlin
db.collection("Users")
    .get()
    .addOnSuccessListener { result ->
        for (document in result) {
            val id = document.id
            val data = document.data
        }
    }
```

### 2) Query cơ bản (lọc / sắp xếp / giới hạn)

```kotlin
db.collection("Users")
    .whereGreaterThan("born", 1990)
    .orderBy("born")
    .limit(20)
    .get()
```

Lưu ý:

- Một số query cần **index** (Firebase Console thường sẽ gợi ý link tạo index khi query lỗi).
- Dữ liệu nên thiết kế để query dễ: ví dụ dùng field `createdAt` (timestamp) để sort/paginate.

---

## Update and Delete Documents

### 1) Update 1 field

```kotlin
db.collection("Users")
    .document("user1")
    .update("born", 1995)
```

### 2) Update nhiều field

```kotlin
db.collection("Users")
    .document("user1")
    .update(
        mapOf(
            "name" to "Jack",
            "lname" to "Reacher"
        )
    )
```

### 3) Các update “nâng cao” hay dùng

```kotlin
import com.google.firebase.firestore.FieldValue

db.collection("Users").document("user1")
    .update("score", FieldValue.increment(1))

db.collection("Users").document("user1")
    .update("tags", FieldValue.arrayUnion("vip"))

db.collection("Users").document("user1")
    .update("tempField", FieldValue.delete())
```

### 4) Delete document

```kotlin
db.collection("Users")
    .document("user2")
    .delete()
```

### (Bổ sung) Batch write và Transaction (khi cần tính nhất quán)

- **WriteBatch**: cập nhật/xóa/ghi nhiều document như 1 “gói” (hoặc tất cả thành công, hoặc tất cả thất bại).
- **Transaction**: đọc → tính toán → ghi, đảm bảo dữ liệu không bị “race condition”.

Khi mới học, bạn có thể bắt đầu với `set/update/delete` trước, sau đó mới nâng lên batch/transaction.

---

## Compare with Firebase

Firebase là **một nền tảng** gồm nhiều sản phẩm: Authentication, Cloud Firestore, Realtime Database, Storage, Functions, Analytics, Crashlytics,...

Khi mọi người nói “so sánh Firestore với Firebase” thì thường là đang so sánh:

- **Cloud Firestore** vs **Firebase Realtime Database**

### Cloud Firestore vs Realtime Database

| Tiêu chí | Cloud Firestore | Realtime Database |
|---|---|---|
| Mô hình dữ liệu | Document/Collection | JSON tree |
| Query | Mạnh hơn, linh hoạt hơn | Hạn chế hơn |
| Scale | Tốt cho nhiều kiểu app lớn | Tốt cho realtime đơn giản |
| Offline | Có (mobile SDK) | Có (mobile SDK) |
| Realtime | Có (snapshot listener) | Có (listener) |
| Use case điển hình | App có nhiều màn, nhiều loại dữ liệu, cần query | Chat/Presence/realtime đơn giản, cấu trúc dữ liệu “cây” rõ |

### Chọn cái nào?

- Chọn **Firestore** khi bạn cần:
  - Query phức tạp hơn (lọc/sort/limit, index)
  - Dữ liệu dạng “bộ sưu tập” rõ ràng (users, posts, comments,...)
  - Dễ mở rộng theo mô-đun
- Chọn **Realtime Database** khi bạn cần:
  - Đồng bộ realtime cực đơn giản theo kiểu JSON tree
  - Presence / trạng thái online/offline (thường được nhắc tới như điểm mạnh)

---

### Gợi ý thực hành theo project hiện tại

Bạn có thể đối chiếu với ví dụ đang có trong `app/src/main/java/com/didan/android/firestore/MainActivity.kt`:

- Tạo collection `Users`
- Ghi 2 document (`user1`, `user2`)
- Đọc toàn bộ documents trong collection
- Update và delete document

Nếu bạn muốn, mình có thể:

- Tách code Firestore ra khỏi `MainActivity` (theo Repository pattern)
- Viết hàm CRUD “chuẩn” hơn (có xử lý lỗi + callback/Flow)
- Bổ sung ví dụ query + realtime listener + rules an toàn để dùng thật
