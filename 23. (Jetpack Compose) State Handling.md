# 23. (Jetpack Compose) State Handling

## Xử lý State trong Android

Tài liệu này giúp bạn hiểu và sử dụng **State trong Jetpack Compose** theo cách dễ nắm bắt cho người mới bắt đầu.  
Bạn sẽ đi từ khái niệm cơ bản đến cách tổ chức code chuẩn trong dự án thực tế.

---

## 1. What's State?

### State là gì?
Trong UI, **state** là dữ liệu hiện tại quyết định giao diện đang hiển thị gì.

Ví dụ:
- Giá trị text trong `TextField`
- Trạng thái bật/tắt của `Switch`
- Danh sách sản phẩm đang hiển thị
- Giá trị bộ đếm (counter)

Trong Jetpack Compose:
- UI được mô tả bằng hàm `@Composable`.
- Khi **state thay đổi**, Compose sẽ tự động cập nhật phần UI liên quan.

Nói ngắn gọn:  
**UI = hàm của State**  
(giao diện là kết quả của dữ liệu trạng thái hiện tại)

---

## 2. Without Using State

Nếu không dùng state đúng cách, UI sẽ không tự cập nhật.

### Ví dụ sai (không dùng `MutableState`)

```kotlin
@Composable
fun CounterBadExample() {
    var count = 0

    Column {
        Text("Count: $count")
        Button(onClick = { count++ }) {
            Text("Tăng")
        }
    }
}
```

### Vấn đề
- `count` chỉ là biến cục bộ thường.
- Mỗi lần composable chạy lại, `count` lại trở về `0`.
- Compose không theo dõi biến này để biết cần cập nhật UI.

Kết quả: nhấn nút nhưng giao diện không hoạt động như mong muốn.

---

## 3. Using Mutable State

Để Compose theo dõi thay đổi, dùng `MutableState`.

### Cách đúng cơ bản

```kotlin
@Composable
fun CounterGoodExample() {
    var count by remember { mutableStateOf(0) }

    Column {
        Text("Count: $count")
        Button(onClick = { count++ }) {
            Text("Tăng")
        }
    }
}
```

### Giải thích
- `mutableStateOf(0)`: tạo state ban đầu là `0`.
- `remember { ... }`: giữ state qua các lần recomposition.
- Khi `count` đổi giá trị, Compose đánh dấu phần đọc `count` để vẽ lại.

---

## 4. Recomposition

### Recomposition là gì?
**Recomposition** là quá trình Compose chạy lại các composable cần thiết khi state thay đổi.

Không phải toàn bộ màn hình luôn bị vẽ lại, mà Compose cố gắng:
- Chỉ recomposition phần bị ảnh hưởng.
- Tối ưu để giảm công việc không cần thiết.

### Ví dụ trực quan

```kotlin
@Composable
fun RecompositionExample() {
    var count by remember { mutableStateOf(0) }

    Column {
        Text("Count: $count") // đọc count -> sẽ cập nhật khi count đổi
        Button(onClick = { count++ }) {
            Text("Tăng")
        }
        StaticFooter() // không đọc count -> thường không cần cập nhật lại
    }
}

@Composable
fun StaticFooter() {
    Text("Footer tĩnh")
}
```

### Lưu ý quan trọng cho người mới
- Recomposition là bình thường, không phải lỗi.
- Tránh làm việc nặng (I/O, xử lý lớn) trực tiếp trong composable.
- Tách composable nhỏ để Compose tối ưu dễ hơn.

---

## 5. Remember Keyword

`remember` dùng để lưu giá trị trong bộ nhớ của composition.

### Không dùng `remember`
Giá trị có thể bị khởi tạo lại khi recomposition.

### Dùng `remember`
Giá trị được giữ lại giữa các lần recomposition của cùng composable.

```kotlin
@Composable
fun RememberExample() {
    val randomNumber = remember { (1..1000).random() }
    Text("Số ngẫu nhiên: $randomNumber")
}
```

### `rememberSaveable`
Nếu muốn giữ state khi:
- xoay màn hình,
- thay đổi cấu hình (configuration change),

hãy dùng `rememberSaveable`.

```kotlin
@Composable
fun SaveableExample() {
    var name by rememberSaveable { mutableStateOf("") }
    TextField(value = name, onValueChange = { name = it })
}
```

---

## 6. Delegation in Kotlin

Bạn sẽ thường thấy cú pháp:

```kotlin
var text by remember { mutableStateOf("") }
```

Đây là **delegation** (`by`) trong Kotlin.

### Delegation hoạt động như thế nào?
`mutableStateOf("")` trả về một `MutableState<String>`.  
`by` giúp bạn làm việc trực tiếp với giá trị bên trong state thay vì phải viết `.value`.

Về ý tưởng, dòng:

```kotlin
var text by remember { mutableStateOf("") }
```

tương đương cách viết dài:

```kotlin
val textState = remember { mutableStateOf("") }
var text: String
    get() = textState.value
    set(value) {
        textState.value = value
    }
```

Vì vậy:
- Đọc `text` thực chất là đọc `textState.value`.
- Gán `text = "abc"` thực chất là gán `textState.value = "abc"`.
- Khi giá trị đổi, Compose nhận biết và recomposition phần liên quan.

### So sánh 2 cách viết

```kotlin
// Cách 1: dùng State object trực tiếp
val textState = remember { mutableStateOf("") }
TextField(
    value = textState.value,
    onValueChange = { textState.value = it }
)
```

```kotlin
// Cách 2: dùng delegation (gọn hơn)
var text by remember { mutableStateOf("") }
TextField(
    value = text,
    onValueChange = { text = it }
)
```

### `val by` và `var by` dùng khi nào?
- Dùng `var by` khi cần vừa đọc vừa ghi state:

```kotlin
var query by remember { mutableStateOf("") }
```

- Dùng `val by` khi state chỉ đọc tại composable đó (ví dụ `derivedStateOf`):

```kotlin
val isValid by remember(query) { derivedStateOf { query.length >= 3 } }
```

### Import cần có khi dùng `by` với Compose State

```kotlin
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
```

Nếu thiếu import, bạn thường gặp lỗi:
- `Type ... has no method 'getValue(...)'`
- `Type ... has no method 'setValue(...)'`

### Lỗi phổ biến người mới hay gặp
- Dùng `val` nhưng lại gán lại:

```kotlin
val text by remember { mutableStateOf("") } // sai nếu bạn cần text = ...
```

- Dùng `remember { 0 }` rồi tăng giảm trực tiếp:

```kotlin
var count = remember { 0 } // count chỉ là Int thường, không phải Compose state
```

Muốn UI tự cập nhật, cần:

```kotlin
var count by remember { mutableStateOf(0) }
```

### Kết luận nhanh
- Cả hai đều đúng.
- `by` giúp code dễ đọc hơn cho trường hợp UI state đơn giản.
- Hãy hiểu bản chất là truy cập `.value` thông qua delegation, không phải "phép màu".

---

## 7. Stateful Composition

### Stateful Composable là gì?
Là composable **tự giữ state bên trong nó**.

Ví dụ:

```kotlin
@Composable
fun StatefulCounter() {
    var count by remember { mutableStateOf(0) }

    Button(onClick = { count++ }) {
        Text("Count: $count")
    }
}
```

### Ưu điểm
- Dễ viết nhanh.
- Phù hợp demo hoặc UI nhỏ.

### Nhược điểm
- Khó tái sử dụng trong nhiều ngữ cảnh.
- Khó test hơn.
- Khó chia sẻ state với màn hình cha.

---

## 8. State Hoisting

### State Hoisting là gì?
Là kỹ thuật **đưa state lên composable cha** để quản lý tập trung.

Thay vì để composable con tự giữ state, ta truyền:
- `value` (state hiện tại)
- `onValueChange` (sự kiện cập nhật state)

### Mẫu chuẩn

```kotlin
@Composable
fun NameInput(
    name: String,
    onNameChange: (String) -> Unit
) {
    TextField(
        value = name,
        onValueChange = onNameChange,
        label = { Text("Tên") }
    )
}
```

Composable cha:

```kotlin
@Composable
fun ProfileScreen() {
    var name by rememberSaveable { mutableStateOf("") }

    Column {
        NameInput(
            name = name,
            onNameChange = { name = it }
        )
        Text("Xin chào, $name")
    }
}
```

### Lợi ích
- Dễ test composable con hơn (vì chỉ nhận input/output).
- Dễ tái sử dụng.
- Dễ tích hợp với `ViewModel`.

---

## 9. Stateful to Stateless

Đây là bước refactor quan trọng trong Compose.

### Bước 1: Stateful version

```kotlin
@Composable
fun EmailInputStateful() {
    var email by remember { mutableStateOf("") }

    TextField(
        value = email,
        onValueChange = { email = it },
        label = { Text("Email") }
    )
}
```

### Bước 2: Stateless version

```kotlin
@Composable
fun EmailInput(
    email: String,
    onEmailChange: (String) -> Unit
) {
    TextField(
        value = email,
        onValueChange = onEmailChange,
        label = { Text("Email") }
    )
}
```

### Bước 3: Wrapper stateful (tuỳ chọn)

Bạn có thể giữ cả 2 phiên bản:
- 1 composable stateless để tái sử dụng.
- 1 composable stateful làm tiện ích nhanh.

```kotlin
@Composable
fun EmailInputStatefulWrapper() {
    var email by rememberSaveable { mutableStateOf("") }
    EmailInput(
        email = email,
        onEmailChange = { email = it }
    )
}
```

### Nguyên tắc khuyến nghị
- Ưu tiên viết **stateless** cho component dùng lại.
- Quản lý state ở màn hình cha hoặc `ViewModel`.
- Dùng stateful wrapper khi cần API tiện lợi.

---

## 10. Bổ sung các loại State thường gặp

Phần này hợp nhất và chuẩn hoá nội dung từ `43. State trong Android với Jetpack Compose.md`.

### 10.1. `MutableState<T>`
Là state có thể thay đổi và Compose theo dõi được.

```kotlin
val countState = mutableStateOf(0)
countState.value += 1
```

Hoặc dạng thường dùng hơn:

```kotlin
var count by remember { mutableStateOf(0) }
count++
```

### 10.2. `remember`
`remember` **không phải** một loại state quan sát được.  
Nó chỉ giúp "ghi nhớ" object/giá trị qua các lần recomposition trong cùng vòng đời composition.

Ví dụ đúng:

```kotlin
val formatter = remember { DecimalFormat("#,###") } // object dùng lại, không tạo lại mỗi lần
```

Nếu cần dữ liệu vừa ghi nhớ vừa làm UI tự cập nhật, kết hợp:

```kotlin
var name by remember { mutableStateOf("") }
```

### 10.3. `derivedStateOf`
Dùng để tạo state dẫn xuất từ state khác, giúp tránh tính toán lại không cần thiết.

```kotlin
@Composable
fun DerivedStateExample() {
    var first by remember { mutableStateOf(0) }
    var second by remember { mutableStateOf(0) }
    val sum by remember { derivedStateOf { first + second } }

    Column {
        Text("Tổng: $sum")
        Button(onClick = { first++ }) { Text("Tăng first") }
        Button(onClick = { second++ }) { Text("Tăng second") }
    }
}
```

### 10.4. `rememberSaveable`
Giữ state qua thay đổi cấu hình (như xoay màn hình) và khôi phục từ `savedInstanceState` khi có thể.

```kotlin
@Composable
fun SaveableCounter() {
    var count by rememberSaveable { mutableStateOf(0) }
    Button(onClick = { count++ }) {
        Text("Count: $count")
    }
}
```

Lưu ý:
- `rememberSaveable` phù hợp cho state UI đơn giản (`String`, `Int`, `Boolean`, `Parcelable`, ...).
- Với kiểu dữ liệu phức tạp, cần `Saver` hoặc đưa state lên `ViewModel`.

### 10.5. `remember { mutableStateOf(...) }`
Đây là mẫu phổ biến nhất cho local UI state trong composable:

```kotlin
var email by remember { mutableStateOf("") }
```

Ý nghĩa:
- `remember`: giữ state object qua recomposition.
- `mutableStateOf`: cho Compose biết đây là state có thể quan sát.

### 10.6. Cách chọn nhanh
- Chỉ cần lưu object tạm, không cần trigger UI: `remember`.
- Cần UI tự cập nhật khi giá trị đổi: `mutableStateOf` (thường đi cùng `remember`).
- Cần giữ state qua cấu hình: `rememberSaveable`.
- Cần state tính từ state khác: `derivedStateOf`.

---

## Tổng kết

Khi làm UI với Jetpack Compose:
- Luôn nghĩ theo hướng dữ liệu: UI phản ánh state.
- Dùng `mutableStateOf` để Compose quan sát thay đổi.
- Dùng `remember`/`rememberSaveable` đúng chỗ.
- Hiểu recomposition để tránh tối ưu sai hướng.
- Ưu tiên `state hoisting` và thiết kế stateless cho component tái sử dụng.

Nếu bạn nắm chắc các mục trong tài liệu này, bạn đã có nền tảng tốt để quản lý state trong Compose ở cả dự án học tập lẫn dự án production.
