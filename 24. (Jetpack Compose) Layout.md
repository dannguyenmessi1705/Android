# 24. Layout in Jetpack Compose

Tài liệu này giải thích chi tiết về các layout quan trọng trong Jetpack Compose dành cho người mới bắt đầu, bám theo đúng ngữ cảnh project hiện tại:

- Kotlin: `2.3.10`
- Compose BOM: `2024.09.00`
- Material 3: `androidx.compose.material3`
- Min SDK: `24`

---

## 1. Layout in Jetpack Compose là gì?

Trong Jetpack Compose, UI được xây dựng bằng **Composable function**.  
Mỗi composable có thể:

- Hiển thị UI (Text, Icon, Button...)
- Chứa composable khác (Row, Column, Box...)
- Nhận `Modifier` để điều chỉnh kích thước, khoảng cách, vị trí, hành vi...

Thay vì XML, Compose dùng Kotlin code để mô tả giao diện theo hướng declarative:

- Bạn mô tả trạng thái UI mong muốn
- Compose tự render lại khi trạng thái thay đổi

---

## 2. Row Deep Dive

`Row` là layout sắp xếp phần tử theo **chiều ngang** (trục chính là horizontal).

### Cú pháp cơ bản

```kotlin
@Composable
fun BasicRow() {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text("Left")
        Text("Right")
    }
}
```

### Các ý quan trọng

- `horizontalArrangement`: cách các phần tử được phân bố theo chiều ngang.
- `verticalAlignment`: cách các phần tử căn theo chiều dọc bên trong Row.
- `Modifier.fillMaxWidth()` giúp Row mở rộng toàn bộ chiều ngang; nếu không, Row chỉ rộng bằng nội dung.

### Row + weight (rất quan trọng)

Khi cần chia đều hoặc chia theo tỉ lệ:

```kotlin
@Composable
fun RowWithWeight() {
    Row(modifier = Modifier.fillMaxWidth()) {
        Text(
            text = "50%",
            modifier = Modifier.weight(1f)
        )
        Text(
            text = "25%",
            modifier = Modifier.weight(0.5f)
        )
        Text(
            text = "25%",
            modifier = Modifier.weight(0.5f)
        )
    }
}
```

`weight()` chỉ có ý nghĩa trong `Row`/`Column` vì nó tham gia vào quá trình đo (measure) của parent.

### Sai lầm thường gặp với Row

- Dùng `fillMaxSize()` trong `BottomAppBar` cho `Row` khiến chiều cao bị kéo giãn không cần thiết.
- Quên `Modifier.padding(...)` nên nội dung dính sát viền.
- Dùng `SpaceAround`/`SpaceEvenly` khi có ít item và màn hình nhỏ có thể tạo cảm giác lệch.

---

## 3. Arrangement & Alignment

Đây là phần dễ nhầm nhất khi mới học Compose.

### Quy tắc nhớ nhanh

- **Arrangement**: sắp xếp item theo **trục chính**.
- **Alignment**: căn item theo **trục phụ**.

Với `Row`:

- Trục chính = ngang => dùng `horizontalArrangement`
- Trục phụ = dọc => dùng `verticalAlignment`

Với `Column`:

- Trục chính = dọc => dùng `verticalArrangement`
- Trục phụ = ngang => dùng `horizontalAlignment`

### Các Arrangement phổ biến

- `Arrangement.Start`
- `Arrangement.End`
- `Arrangement.Center`
- `Arrangement.SpaceBetween`
- `Arrangement.SpaceAround`
- `Arrangement.SpaceEvenly`
- `Arrangement.spacedBy(8.dp)` (thực tế dùng rất nhiều)

### Các Alignment phổ biến

- `Alignment.Start`, `CenterHorizontally`, `End` (cho chiều ngang trong Column)
- `Alignment.Top`, `CenterVertically`, `Bottom` (cho chiều dọc trong Row)
- Trong `Box`: `Alignment.TopStart`, `Center`, `BottomEnd`...

### Ví dụ ngắn

```kotlin
@Composable
fun ArrangementAlignmentExample() {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterVertically),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Item 1")
        Text("Item 2")
        Text("Item 3")
    }
}
```

---

## 4. Exploring Columns

`Column` sắp xếp item theo **chiều dọc**, phù hợp cho form, profile, settings, màn hình onboarding.

### Ví dụ cơ bản

```kotlin
@Composable
fun BasicColumn() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp),
        horizontalAlignment = Alignment.Start
    ) {
        Text("Tên")
        Text("Email")
        Text("Số điện thoại")
    }
}
```

### Khi Column không đủ

Nếu danh sách dài và cần cuộn:

- Dùng `LazyColumn` thay vì `Column`.
- `Column` render toàn bộ item ngay lập tức (tốn tài nguyên khi dữ liệu lớn).

### Best practices

- Luôn đặt `padding` ở parent để có khoảng thở.
- Kết hợp `verticalArrangement = Arrangement.spacedBy(...)` để code gọn, dễ đọc.
- Dùng `weight` khi muốn vùng nào đó co giãn theo màn hình (ví dụ form + footer button).

---

## 5. Exploring Box

`Box` dùng để xếp chồng (stack/overlay) các phần tử.

Các tình huống điển hình:

- Ảnh + badge góc phải
- Nút nổi trên ảnh
- Loading overlay che nội dung

### Ví dụ

```kotlin
@Composable
fun BoxOverlayExample() {
    Box(
        modifier = Modifier
            .size(220.dp)
            .padding(8.dp)
    ) {
        Surface(
            modifier = Modifier.matchParentSize(),
            color = Color(0xFFE3F2FD)
        ) {}

        Text(
            text = "Nội dung chính",
            modifier = Modifier.align(Alignment.Center)
        )

        Text(
            text = "NEW",
            modifier = Modifier
                .align(Alignment.TopEnd)
                .padding(8.dp),
            color = Color.Red
        )
    }
}
```

### Mẹo quan trọng

- `Modifier.align(...)` trong `Box` là cho **từng child**, không phải cho Box.
- `contentAlignment` trong `Box(...)` là căn mặc định cho mọi child (trừ child nào có `align` riêng).
- Dùng `matchParentSize()` khi cần layer phủ đúng toàn bộ Box.

---

## 6. Exploring Surface

`Surface` là composable nền tảng của Material 3 để tạo vùng hiển thị có:

- màu nền (`color`)
- màu nội dung mặc định (`contentColor`)
- bo góc (`shape`)
- bóng (`shadowElevation`/`tonalElevation`)
- viền (`border`)

### Ví dụ thực tế

```kotlin
@Composable
fun SurfaceCard() {
    Surface(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp),
        color = Color.White,
        tonalElevation = 2.dp,
        shadowElevation = 4.dp,
        border = BorderStroke(1.dp, Color(0xFFE0E0E0))
    ) {
        Column(Modifier.padding(16.dp)) {
            Text("Surface Title")
            Text("Surface giúp tạo container theo Material.")
        }
    }
}
```

### So sánh nhanh

- `Box`: layout thuần để xếp chồng.
- `Surface`: container theo Material, có ngữ nghĩa giao diện và style.

Nếu bạn cần vùng UI giống "card/panel/background layer", nên ưu tiên `Surface`.

---

## 7. The Scaffold

`Scaffold` là layout khung màn hình chuẩn Material, gom các slot:

- `topBar`
- `bottomBar`
- `floatingActionButton`
- `snackbarHost`
- `content`

### Cực kỳ quan trọng: `innerPadding`

Trong project hiện tại, `Scaffold` đang gọi `MyColumn()` trực tiếp nên có thể bị chồng lên app bar.  
Cách đúng là truyền `innerPadding` vào content:

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyScaffold() {
    Scaffold(
        modifier = Modifier.fillMaxSize(),
        topBar = { MyTopAppBar() },
        bottomBar = { MyBottomAppBar() },
        floatingActionButton = { MyFloatingActionButton() }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text("Nội dung chính")
            Text("Không bị đè bởi Top/Bottom App Bar")
        }
    }
}
```

### Khi nào dùng Scaffold?

- Màn hình có app bar, FAB, bottom bar.
- Cần cấu trúc nhất quán giữa nhiều screen.

Không bắt buộc mọi màn hình đều dùng `Scaffold`, nhưng đa số màn hình chính nên dùng.

---

## 8. Top App Bar

`TopAppBar` hiển thị phần đầu màn hình: tiêu đề, điều hướng, action.

### Ví dụ chuẩn Material 3

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyTopAppBar(onMenuClick: () -> Unit, onSettingsClick: () -> Unit) {
    TopAppBar(
        title = { Text("Top App Bar") },
        navigationIcon = {
            IconButton(onClick = onMenuClick) {
                Icon(
                    painter = painterResource(R.drawable.outline_density_medium_24),
                    contentDescription = "Menu"
                )
            }
        },
        actions = {
            IconButton(onClick = onSettingsClick) {
                Icon(
                    painter = painterResource(R.drawable.outline_build_circle_24),
                    contentDescription = "Settings"
                )
            }
        },
        colors = TopAppBarDefaults.topAppBarColors(
            containerColor = Color.Red,
            titleContentColor = Color.Blue
        )
    )
}
```

### Nâng cao

- Dùng `CenterAlignedTopAppBar` nếu muốn title ở giữa.
- Với màn hình cuộn, có thể kết hợp `TopAppBarDefaults.enterAlwaysScrollBehavior()`.
- Nên truyền callback (`onMenuClick`) thay vì viết logic trực tiếp để dễ test/tái sử dụng.

---

## 9. Bottom App Bar

`BottomAppBar` là thanh hành động dưới màn hình, thường chứa icon điều hướng hoặc tác vụ nhanh.

### Ví dụ gọn, dễ kiểm soát

```kotlin
@Composable
fun MyBottomAppBar(
    onHomeClick: () -> Unit,
    onBookmarkClick: () -> Unit
) {
    BottomAppBar(
        containerColor = Color.DarkGray,
        contentColor = Color.Yellow
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 8.dp),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            IconButton(onClick = onHomeClick) {
                Icon(
                    painter = painterResource(R.drawable.outline_add_home_24),
                    contentDescription = "Home"
                )
            }
            IconButton(onClick = onBookmarkClick) {
                Icon(
                    painter = painterResource(R.drawable.outline_bookmark_24),
                    contentDescription = "Bookmark"
                )
            }
        }
    }
}
```

### Lưu ý thực chiến

- Tránh `Modifier.fillMaxSize()` trong content của `BottomAppBar`; dùng `fillMaxWidth()` là đủ.
- Nếu app thiên về điều hướng tab, cân nhắc `NavigationBar` thay vì `BottomAppBar`.

---

## 10. Floating Action Button (FAB)

FAB là nút hành động chính nổi bật của màn hình.

### Ví dụ

```kotlin
@Composable
fun MyFloatingActionButton(onAddClick: () -> Unit) {
    FloatingActionButton(
        onClick = onAddClick,
        containerColor = Color.Green,
        contentColor = Color.White
    ) {
        Icon(
            painter = painterResource(R.drawable.outline_add_24),
            contentDescription = "Add"
        )
    }
}
```

### Nâng cao

- Dùng `ExtendedFloatingActionButton` nếu cần cả icon + text.
- Khi đặt FAB trong `Scaffold`, có thể chỉnh vị trí bằng `floatingActionButtonPosition`.
- Chỉ nên có **1 hành động chính** tương ứng 1 FAB ở mỗi màn hình.

---

## 11. Mẫu tích hợp hoàn chỉnh cho project hiện tại

Bạn có thể ghép tất cả thành 1 màn hình như sau:

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LayoutShowcaseScreen() {
    val context = LocalContext.current

    Scaffold(
        topBar = {
            MyTopAppBar(
                onMenuClick = {
                    Toast.makeText(context, "Menu clicked", Toast.LENGTH_SHORT).show()
                },
                onSettingsClick = {
                    Toast.makeText(context, "Settings clicked", Toast.LENGTH_SHORT).show()
                }
            )
        },
        bottomBar = {
            MyBottomAppBar(
                onHomeClick = {
                    Toast.makeText(context, "Home clicked", Toast.LENGTH_SHORT).show()
                },
                onBookmarkClick = {
                    Toast.makeText(context, "Bookmark clicked", Toast.LENGTH_SHORT).show()
                }
            )
        },
        floatingActionButton = {
            MyFloatingActionButton(
                onAddClick = {
                    Toast.makeText(context, "FAB clicked", Toast.LENGTH_SHORT).show()
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text("Row Demo")
            MyRow()

            Text("Box Demo")
            MyBox()

            Text("Surface Demo")
            SurfaceCard()
        }
    }
}
```

---

## 12. Checklist cho người mới bắt đầu

- Dùng `Row` khi cần layout ngang, `Column` khi cần layout dọc, `Box` khi cần chồng lớp.
- Dùng `Surface` làm container theo Material.
- Dùng `Scaffold` cho khung màn hình chuẩn.
- Luôn xử lý `innerPadding` từ `Scaffold`.
- Ưu tiên callback parameter (`onClick`) để composable dễ tái sử dụng.
- Thêm `contentDescription` cho icon để hỗ trợ accessibility.

---

## 13. Tóm tắt nhanh

- `Row`: chia ngang, mạnh với `weight`.
- `Column`: chia dọc, dễ dựng form.
- `Box`: overlay, badge, loading.
- `Surface`: nền Material có style.
- `Scaffold`: khung tổng thể màn hình.
- `TopAppBar`, `BottomAppBar`, `FAB`: các thành phần điều hướng và hành động chính theo Material 3.

Nếu nắm vững 9 thành phần ở trên, bạn đã có nền tảng rất tốt để xây dựng đa số màn hình trong Jetpack Compose.

---

## 14. ConstraintLayput in Jetpack Compose (ConstraintLayout)

Phần này mở rộng theo đúng project hiện tại, nơi bạn đã có sẵn dependency:

- `androidx.constraintlayout:constraintlayout-compose` (qua `libs.androidx.constraintlayout.compose`)
- Version hiện tại trong project: `1.1.1`

ConstraintLayout trong Compose đặc biệt hữu ích khi giao diện có nhiều quan hệ ràng buộc chéo mà `Row`/`Column`/`Box` sẽ khó giữ code gọn và khó scale khi màn hình phức tạp hơn.

### 14.1 Introduction to Constraint Layout

**ConstraintLayout** là layout cho phép bạn đặt vị trí phần tử dựa trên quan hệ ràng buộc:

- Ràng buộc với `parent` (màn hình cha)
- Ràng buộc giữa các composable với nhau
- Ràng buộc theo đường dẫn hướng (Guideline), rào cản động (Barrier), hoặc chuỗi (Chain)

Khi nào nên dùng:

- Màn hình có nhiều thành phần cần canh theo nhau (avatar, title, subtitle, action button...)
- Cần thích ứng với nội dung động (text ngắn/dài)
- Muốn giảm nhiều lớp `Row` + `Column` lồng nhau

Khi nào chưa cần dùng:

- Layout rất đơn giản theo một trục: ưu tiên `Row`/`Column`
- Overlay đơn giản: ưu tiên `Box`

### 14.2 Creating Constraint Layout

Để tạo một `ConstraintLayout` trong Compose, bạn sẽ đi theo quy trình:

1. Tạo `ConstraintLayout { ... }`
2. Tạo references bằng `createRefs()` hoặc `createRefFor("id")`
3. Gán ràng buộc cho từng phần tử bằng `Modifier.constrainAs(ref) { ... }`

Ví dụ cơ bản:

```kotlin
@Composable
fun ProfileHeader() {
    ConstraintLayout(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        val (avatarRef, nameRef, roleRef, followRef) = createRefs()

        Box(
            modifier = Modifier
                .size(56.dp)
                .background(Color.Gray, shape = CircleShape)
                .constrainAs(avatarRef) {
                    start.linkTo(parent.start)
                    top.linkTo(parent.top)
                }
        )

        Text(
            text = "Nguyen Van A",
            modifier = Modifier.constrainAs(nameRef) {
                start.linkTo(avatarRef.end, margin = 12.dp)
                top.linkTo(avatarRef.top)
                end.linkTo(followRef.start, margin = 12.dp)
                width = Dimension.fillToConstraints
            }
        )

        Text(
            text = "Android Developer",
            color = Color.DarkGray,
            modifier = Modifier.constrainAs(roleRef) {
                start.linkTo(nameRef.start)
                top.linkTo(nameRef.bottom, margin = 4.dp)
                end.linkTo(nameRef.end)
                width = Dimension.fillToConstraints
            }
        )

        Button(
            onClick = {},
            modifier = Modifier.constrainAs(followRef) {
                end.linkTo(parent.end)
                top.linkTo(parent.top)
                bottom.linkTo(roleRef.bottom)
            }
        ) {
            Text("Follow")
        }
    }
}
```

Điểm quan trọng trong ví dụ trên:

- `nameRef` và `roleRef` dùng `Dimension.fillToConstraints` để tự co giãn theo vùng ràng buộc.
- `followRef` neo về cạnh phải parent, nên khi text dài layout vẫn ổn định.

### 14.3 `constrainAs()`

`constrainAs()` là trung tâm của ConstraintLayout trong Compose.

Mẫu chung:

```kotlin
Modifier.constrainAs(myRef) {
    start.linkTo(parent.start)
    top.linkTo(parent.top)
}
```

Những ràng buộc dùng nhiều nhất:

- `start.linkTo(...)`, `end.linkTo(...)`
- `top.linkTo(...)`, `bottom.linkTo(...)`
- `centerHorizontallyTo(...)`, `centerVerticallyTo(...)`
- `width = Dimension.fillToConstraints` / `height = Dimension.fillToConstraints`

Ví dụ phần tử chiếm hết vùng giữa 2 cạnh:

```kotlin
Text(
    text = "Nội dung có thể rất dài...",
    modifier = Modifier.constrainAs(contentRef) {
        start.linkTo(parent.start, margin = 16.dp)
        end.linkTo(parent.end, margin = 16.dp)
        top.linkTo(parent.top, margin = 16.dp)
        width = Dimension.fillToConstraints
    }
)
```

Nếu bỏ `width = Dimension.fillToConstraints`, `Text` có thể chỉ rộng theo nội dung, không lấp đầy vùng giữa 2 ràng buộc.

### 14.4 Guidelines

`Guideline` là đường tham chiếu ảo để canh nhiều phần tử theo cùng một mốc.

Bạn có thể tạo guideline theo:

- Phần trăm: `createGuidelineFromStart(0.1f)` (10% từ trái)
- Khoảng cách cố định: `createGuidelineFromTop(80.dp)`

Ví dụ:

```kotlin
ConstraintLayout(modifier = Modifier.fillMaxSize()) {
    val titleRef = createRef()
    val startGuide = createGuidelineFromStart(0.1f)

    Text(
        text = "Dashboard",
        modifier = Modifier.constrainAs(titleRef) {
            start.linkTo(startGuide)
            top.linkTo(parent.top, margin = 24.dp)
        }
    )
}
```

Khi dùng guideline:

- Dễ giữ alignment nhất quán giữa nhiều màn hình.
- Dễ responsive vì chỉ cần đổi tỉ lệ hoặc mốc `dp`.

### 14.5 Barriers

`Barrier` tạo mốc động dựa trên cạnh ngoài cùng của một nhóm phần tử.

Rất hữu ích khi nội dung động (text dài/ngắn khác nhau) vì bạn không cần hard-code vị trí tiếp theo.

Ví dụ:

```kotlin
ConstraintLayout(modifier = Modifier.fillMaxWidth()) {
    val (labelRef, valueRef, noteRef) = createRefs()

    Text(
        text = "Họ tên:",
        modifier = Modifier.constrainAs(labelRef) {
            start.linkTo(parent.start, 16.dp)
            top.linkTo(parent.top, 16.dp)
        }
    )

    Text(
        text = "Nguyễn Văn B (Tên có thể dài)",
        modifier = Modifier.constrainAs(valueRef) {
            start.linkTo(labelRef.end, 8.dp)
            top.linkTo(labelRef.top)
        }
    )

    val textEndBarrier = createEndBarrier(labelRef, valueRef)

    Text(
        text = "Đã xác minh",
        modifier = Modifier.constrainAs(noteRef) {
            start.linkTo(textEndBarrier, 12.dp)
            top.linkTo(labelRef.top)
        }
    )
}
```

Trong ví dụ này, `noteRef` luôn bắt đầu sau phần tử dài nhất giữa `labelRef` và `valueRef`.

### 14.6 Chains

`Chain` giúp nhóm nhiều phần tử theo một trục và điều khiển cách phân phối khoảng trống.

Hai loại chain:

- `createHorizontalChain(...)`
- `createVerticalChain(...)`

Các kiểu `ChainStyle` thường dùng:

- `ChainStyle.Spread`: phần tử dàn đều trên toàn bộ không gian.
- `ChainStyle.SpreadInside`: phần tử đầu/cuối bám biên, phần giữa dàn đều.
- `ChainStyle.Packed`: các phần tử gom lại thành cụm (có thể chỉnh bias).

Ví dụ horizontal chain:

```kotlin
ConstraintLayout(modifier = Modifier.fillMaxWidth()) {
    val (chip1, chip2, chip3) = createRefs()

    Text(
        text = "Mới",
        modifier = Modifier.constrainAs(chip1) {
            top.linkTo(parent.top, 16.dp)
        }
    )
    Text(
        text = "Phổ biến",
        modifier = Modifier.constrainAs(chip2) {
            top.linkTo(chip1.top)
        }
    )
    Text(
        text = "Đề xuất",
        modifier = Modifier.constrainAs(chip3) {
            top.linkTo(chip1.top)
        }
    )

    createHorizontalChain(
        chip1, chip2, chip3,
        chainStyle = ChainStyle.SpreadInside
    )

    constrain(chip1) { start.linkTo(parent.start, 16.dp) }
    constrain(chip3) { end.linkTo(parent.end, 16.dp) }
}
```

Nếu muốn gom cụm ở giữa:

```kotlin
createHorizontalChain(
    chip1, chip2, chip3,
    chainStyle = ChainStyle.Packed
)
```

### 14.7 Gợi ý thực hành cho người mới

- Bắt đầu với 2-3 phần tử và ràng buộc cơ bản `start/top`.
- Thêm `Guideline` khi thấy nhiều phần tử cần cùng cột hoặc cùng mốc.
- Dùng `Barrier` ngay khi có text động để tránh chồng lấn.
- Dùng `Chain` để thay thế việc tự tính spacing thủ công.
- Luôn preview nhiều kích thước màn hình để kiểm tra tính ổn định layout.
