# Adapter & Their Usage

Tài liệu này hướng dẫn chi tiết về Adapter trong Android cho người mới bắt đầu. Mục tiêu là hiểu bản chất Adapter, biết khi nào nên viết Custom Adapter, nắm các phương thức quan trọng, và tối ưu hiệu năng với `convertView` và `LayoutInflater`. Tài liệu cũng mở rộng phần `RecyclerView.Adapter` với nhiều ví dụ thực tế.

## Mục tiêu học

- Hiểu vai trò của Adapter trong việc hiển thị dữ liệu dạng danh sách.
- Biết chọn đúng loại Adapter cho từng trường hợp.
- Viết được Custom Adapter (ListView/RecyclerView) từ đầu.
- Hiểu rõ `getView`, `convertView`, `LayoutInflater` và ViewHolder.
- Biết cách cập nhật dữ liệu hiệu quả và tránh lỗi phổ biến.

## What's Adapter?

**Adapter** là lớp trung gian giúp “dịch” dữ liệu (data source) thành các View con để hiển thị trong UI, thường dùng với:
- `ListView`
- `GridView`
- `Spinner`
- `RecyclerView`

Bạn có thể hình dung Adapter như một “người phục vụ”: nhận dữ liệu từ danh sách, rồi tạo/đổ dữ liệu vào từng item để hiển thị lên màn hình.

### Thành phần trong mô hình Adapter

- **Nguồn dữ liệu**: List/Array/MutableList hoặc dữ liệu từ database/network.
- **Layout item**: XML mô tả 1 dòng item hiển thị.
- **Adapter**: biết cách lấy dữ liệu từ nguồn và gán vào View.
- **ViewGroup**: `ListView`/`RecyclerView` hiển thị các item.

### Sơ đồ luồng Adapter (minh họa)

```
Data Source (List/Array)
        |
        v
     Adapter
        |
        v
Tạo/Tái sử dụng View (item)
        |
        v
ViewGroup (ListView/RecyclerView)
```

### Vòng đời hiển thị cơ bản

1. ViewGroup hỏi Adapter: “Có bao nhiêu item?”
2. Adapter trả về số lượng và tạo/bind dữ liệu vào View item.
3. Khi cuộn, View cũ được tái sử dụng (recycle) để giảm tạo mới.

### Lợi ích của Adapter

- Tách biệt dữ liệu và giao diện.
- Tái sử dụng UI item.
- Tối ưu hiệu năng bằng cơ chế tái sử dụng View.
- Dễ mở rộng khi thay đổi cấu trúc dữ liệu.

### Các loại Adapter phổ biến

- `ArrayAdapter`: dữ liệu đơn giản, một dòng text hoặc layout cơ bản.
- `SimpleAdapter`: dữ liệu dạng `Map`, phù hợp cho cấu trúc đơn giản.
- `BaseAdapter`: linh hoạt nhất cho `ListView`/`GridView`.
- `CursorAdapter`: dùng với dữ liệu từ database (Cursor).
- `RecyclerView.Adapter`: tiêu chuẩn mới cho danh sách lớn.
- `ListAdapter` (RecyclerView): kết hợp `DiffUtil` để cập nhật hiệu quả.

## Chuẩn bị dữ liệu và layout mẫu

### 1) Model dữ liệu

```kotlin
data class Currency(val name: String, val code: String, val rate: Double)
```

### 2) Layout item (res/layout/item_currency.xml)

```xml
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="12dp">

    <TextView
        android:id="@+id/tvName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="USD - US Dollar"
        android:textSize="16sp" />

    <TextView
        android:id="@+id/tvCode"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="USD"
        android:textSize="14sp" />

    <TextView
        android:id="@+id/tvRate"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="24,500"
        android:textSize="14sp" />
</LinearLayout>
```

## Custom Adapters

Khi dữ liệu phức tạp (nhiều trường) hoặc giao diện item tùy biến, bạn cần viết **Custom Adapter** thay vì dùng `ArrayAdapter` hay `SimpleAdapter`.

### Khi nào nên viết Custom Adapter?

- Item có nhiều trường dữ liệu (ảnh, tiêu đề, mô tả, giá, ...).
- Layout item không có sẵn, cần thiết kế riêng.
- Cần logic hiển thị đặc biệt (đổi màu, ẩn/hiện theo trạng thái).
- Cần tối ưu hiệu năng cho danh sách dài.

### Ví dụ đầy đủ: ListView + BaseAdapter

#### Bước 1: XML chứa ListView (res/layout/activity_main.xml)

```xml
<ListView
    android:id="@+id/lvCurrency"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

#### Bước 2: Tạo Adapter với ViewHolder

```kotlin
class CurrencyAdapter(
    private val items: List<Currency>,
    private val inflater: LayoutInflater
) : BaseAdapter() {

    private class ViewHolder(view: View) {
        val tvName: TextView = view.findViewById(R.id.tvName)
        val tvCode: TextView = view.findViewById(R.id.tvCode)
        val tvRate: TextView = view.findViewById(R.id.tvRate)
    }

    override fun getCount(): Int = items.size

    override fun getItem(position: Int): Any = items[position]

    override fun getItemId(position: Int): Long = position.toLong()

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        val view: View
        val holder: ViewHolder

        if (convertView == null) {
            view = inflater.inflate(R.layout.item_currency, parent, false)
            holder = ViewHolder(view)
            view.tag = holder
        } else {
            view = convertView
            holder = view.tag as ViewHolder
        }

        val item = items[position]
        holder.tvName.text = item.name
        holder.tvCode.text = item.code
        holder.tvRate.text = item.rate.toString()
        return view
    }
}
```

#### Bước 3: Gán Adapter trong Activity/Fragment

```kotlin
val items = listOf(
    Currency("US Dollar", "USD", 24500.0),
    Currency("Euro", "EUR", 26500.0)
)

val adapter = CurrencyAdapter(items, layoutInflater)
lvCurrency.adapter = adapter
```

### Ví dụ đơn giản với ArrayAdapter và layout tùy biến

```kotlin
class CurrencyArrayAdapter(
    context: Context,
    private val items: List<Currency>
) : ArrayAdapter<Currency>(context, R.layout.item_currency, items) {

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        val view = convertView ?: LayoutInflater.from(context)
            .inflate(R.layout.item_currency, parent, false)
        val item = items[position]

        view.findViewById<TextView>(R.id.tvName).text = item.name
        view.findViewById<TextView>(R.id.tvCode).text = item.code
        view.findViewById<TextView>(R.id.tvRate).text = item.rate.toString()
        return view
    }
}
```

## Adapter Methods

Dưới đây là các phương thức quan trọng, tùy theo loại Adapter.

### 1) BaseAdapter / ArrayAdapter (ListView, GridView, Spinner)

- `getCount()`
  Trả về số lượng item, ListView dùng giá trị này để biết chiều dài danh sách.
- `getItem(position)`
  Lấy dữ liệu tại vị trí `position`.
- `getItemId(position)`
  Trả về ID của item (thường là `position` nếu không có ID riêng).
- `getView(position, convertView, parent)`
  Tạo hoặc tái sử dụng View và gán dữ liệu vào từng item.

Ngoài ra thường dùng:
- `notifyDataSetChanged()`
  Gọi khi dữ liệu thay đổi để cập nhật UI.
- `notifyDataSetInvalidated()`
  Báo dữ liệu không còn hợp lệ (ít dùng).
- `getViewTypeCount()` và `getItemViewType(position)`
  Dùng khi có nhiều loại item layout.
- `isEnabled(position)`
  Cho phép tắt tương tác cho một item (ví dụ: header).

### 2) RecyclerView.Adapter (RecyclerView)

- `onCreateViewHolder(parent, viewType)`
  Tạo ViewHolder bằng cách inflate layout item.
- `onBindViewHolder(holder, position)`
  Gán dữ liệu vào ViewHolder tại vị trí `position`.
- `getItemCount()`
  Số lượng phần tử.
- `getItemViewType(position)`
  Trả về loại item (layout khác nhau).
- `onViewRecycled(holder)`
  Giải phóng/bỏ lắng nghe để tránh rò rỉ.
- `onViewAttachedToWindow(holder)` / `onViewDetachedFromWindow(holder)`
  Khi item được gắn hoặc tháo khỏi màn hình.

## RecyclerView.Adapter chi tiết

### Thiết lập RecyclerView cơ bản

`RecyclerView` luôn cần `LayoutManager` để sắp xếp item:

```kotlin
recyclerView.layoutManager = LinearLayoutManager(this)
recyclerView.adapter = CurrencyRvAdapter(items)
recyclerView.setHasFixedSize(true)
```

Các loại `LayoutManager` phổ biến:
- `LinearLayoutManager`: danh sách dọc/ngang.
- `GridLayoutManager`: dạng lưới.
- `StaggeredGridLayoutManager`: lưới không đều.

### Cấu trúc tối thiểu

```kotlin
class CurrencyViewHolder(view: View) : RecyclerView.ViewHolder(view) {
    val tvName: TextView = view.findViewById(R.id.tvName)
    val tvCode: TextView = view.findViewById(R.id.tvCode)
    val tvRate: TextView = view.findViewById(R.id.tvRate)
}

class CurrencyRvAdapter(
    private val items: MutableList<Currency>
) : RecyclerView.Adapter<CurrencyViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CurrencyViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_currency, parent, false)
        return CurrencyViewHolder(view)
    }

    override fun onBindViewHolder(holder: CurrencyViewHolder, position: Int) {
        val item = items[position]
        holder.tvName.text = item.name
        holder.tvCode.text = item.code
        holder.tvRate.text = item.rate.toString()
    }

    override fun getItemCount(): Int = items.size
}
```

### Cập nhật dữ liệu hiệu quả

Thay vì `notifyDataSetChanged()` (gây redraw toàn bộ), nên dùng các phương thức cụ thể:
- `notifyItemInserted(position)`
- `notifyItemRemoved(position)`
- `notifyItemChanged(position)`
- `notifyItemRangeChanged(start, count)`

Ví dụ:

```kotlin
items.add(newItem)
notifyItemInserted(items.size - 1)
```

### DiffUtil + ListAdapter (khuyên dùng)

`ListAdapter` giúp tự so sánh dữ liệu cũ/mới để chỉ cập nhật phần thay đổi.

```kotlin
class CurrencyDiff : DiffUtil.ItemCallback<Currency>() {
    override fun areItemsTheSame(oldItem: Currency, newItem: Currency): Boolean {
        return oldItem.code == newItem.code
    }

    override fun areContentsTheSame(oldItem: Currency, newItem: Currency): Boolean {
        return oldItem == newItem
    }
}

class CurrencyListAdapter :
    ListAdapter<Currency, CurrencyViewHolder>(CurrencyDiff()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CurrencyViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_currency, parent, false)
        return CurrencyViewHolder(view)
    }

    override fun onBindViewHolder(holder: CurrencyViewHolder, position: Int) {
        val item = getItem(position)
        holder.tvName.text = item.name
        holder.tvCode.text = item.code
        holder.tvRate.text = item.rate.toString()
    }
}
```

Sử dụng:

```kotlin
val adapter = CurrencyListAdapter()
recyclerView.adapter = adapter
adapter.submitList(newList)
```

### Nhiều loại item (viewType)

```kotlin
override fun getItemViewType(position: Int): Int {
    return if (items[position].rate > 100) 1 else 0
}
```

Trong `onCreateViewHolder`, inflate layout theo `viewType`.

### Click item an toàn

```kotlin
class CurrencyRvAdapter(
    private val items: List<Currency>,
    private val onClick: (Currency) -> Unit
) : RecyclerView.Adapter<CurrencyViewHolder>() {

    override fun onBindViewHolder(holder: CurrencyViewHolder, position: Int) {
        holder.itemView.setOnClickListener {
            val safePos = holder.bindingAdapterPosition
            if (safePos != RecyclerView.NO_POSITION) {
                onClick(items[safePos])
            }
        }
    }
}
```

### Payload updates (cập nhật một phần)

```kotlin
notifyItemChanged(position, "RATE_ONLY")

override fun onBindViewHolder(
    holder: CurrencyViewHolder,
    position: Int,
    payloads: MutableList<Any>
) {
    if (payloads.contains("RATE_ONLY")) {
        holder.tvRate.text = items[position].rate.toString()
    } else {
        super.onBindViewHolder(holder, position, payloads)
    }
}
```

### Stable IDs (giúp animation mượt hơn)

```kotlin
override fun getItemId(position: Int): Long {
    return items[position].code.hashCode().toLong()
}

init {
    setHasStableIds(true)
}
```

### Trang trí danh sách (Divider)

```kotlin
val divider = DividerItemDecoration(this, DividerItemDecoration.VERTICAL)
recyclerView.addItemDecoration(divider)
```

### Thực hành tốt khi dùng RecyclerView

- Tránh xử lý nặng trong `onBindViewHolder` (ví dụ: đọc file, tính toán lớn).
- Dùng `setHasFixedSize(true)` nếu kích thước item cố định.
- Dùng `ListAdapter` + `DiffUtil` để tối ưu cập nhật.
- Không giữ tham chiếu `Context` dài hạn trong `ViewHolder`.
- Khi dữ liệu lớn, hạn chế gọi `notifyDataSetChanged()` liên tục.

## ConvertView & Layout Inflater

### ConvertView là gì?

Trong `ListView`/`GridView`, `convertView` là View cũ được tái sử dụng để tránh tạo mới liên tục. Nếu `convertView` khác `null`, bạn nên tái dùng nó để tăng hiệu năng.

Ví dụ:

```kotlin
val view = convertView ?: inflater.inflate(R.layout.item_currency, parent, false)
```

**Lưu ý quan trọng:**
- Luôn cập nhật toàn bộ dữ liệu cho view (không chỉ một phần).
- Tránh tạo View mới cho mọi item vì sẽ gây giật lag.

### LayoutInflater là gì?

`LayoutInflater` dùng để “bơm” (inflate) file XML thành đối tượng View.

```kotlin
val view = inflater.inflate(R.layout.item_currency, parent, false)
```

Lưu ý:
- Thường dùng `LayoutInflater.from(context)` hoặc `layoutInflater` trong Activity.
- Tham số `parent` giúp View nhận đúng `LayoutParams`.
- `attachToRoot` nên là `false` khi inflate cho Adapter.

### ViewHolder Pattern (tối ưu thêm)

Để tránh gọi `findViewById` nhiều lần, dùng ViewHolder:

```kotlin
class ViewHolder(view: View) {
    val tvName: TextView = view.findViewById(R.id.tvName)
    val tvCode: TextView = view.findViewById(R.id.tvCode)
    val tvRate: TextView = view.findViewById(R.id.tvRate)
}

override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
    val view: View
    val holder: ViewHolder

    if (convertView == null) {
        view = inflater.inflate(R.layout.item_currency, parent, false)
        holder = ViewHolder(view)
        view.tag = holder
    } else {
        view = convertView
        holder = view.tag as ViewHolder
    }

    val item = items[position]
    holder.tvName.text = item.name
    holder.tvCode.text = item.code
    holder.tvRate.text = item.rate.toString()
    return view
}
```

Với `RecyclerView`, ViewHolder là bắt buộc và đã được tích hợp sẵn trong `RecyclerView.Adapter`.

## Spinner Adapter (ví dụ nhanh)

```kotlin
val codes = listOf("USD", "EUR", "JPY")
val adapter = ArrayAdapter(
    this,
    android.R.layout.simple_spinner_item,
    codes
)
adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
spinner.adapter = adapter
```

## GridView Adapter (ví dụ nhanh)

```kotlin
val adapter = ArrayAdapter(
    this,
    android.R.layout.simple_list_item_1,
    listOf("USD", "EUR", "JPY")
)
gridView.numColumns = 3
gridView.adapter = adapter
```

## Lọc dữ liệu (Filterable) cơ bản

Khi cần tìm kiếm trong ListView, bạn có thể dùng `Filterable`:

```kotlin
class CurrencyFilterAdapter(
    context: Context,
    private val allItems: List<Currency>
) : ArrayAdapter<Currency>(context, R.layout.item_currency, allItems), Filterable {

    private var filteredItems = allItems.toMutableList()

    override fun getCount(): Int = filteredItems.size

    override fun getItem(position: Int): Currency? = filteredItems[position]

    override fun getFilter(): Filter {
        return object : Filter() {
            override fun performFiltering(constraint: CharSequence?): FilterResults {
                val query = constraint?.toString()?.lowercase().orEmpty()
                val result = if (query.isEmpty()) {
                    allItems
                } else {
                    allItems.filter { it.code.lowercase().contains(query) }
                }
                return FilterResults().apply { values = result }
            }

            override fun publishResults(constraint: CharSequence?, results: FilterResults?) {
                filteredItems = (results?.values as? List<Currency>)?.toMutableList()
                    ?: mutableListOf()
                notifyDataSetChanged()
            }
        }
    }
}
```

## So sánh nhanh ListView và RecyclerView

- `ListView`: đơn giản, dễ dùng, phù hợp danh sách nhỏ, tái sử dụng qua `convertView`.
- `RecyclerView`: linh hoạt, hỗ trợ nhiều layout, hiệu năng tốt hơn cho danh sách lớn.
- Dự án mới thường ưu tiên `RecyclerView` vì dễ mở rộng và tối ưu.

## Lỗi thường gặp và cách tránh

- **Inflate sai parent**: dùng `inflate(layout, parent, false)` để nhận đúng LayoutParams.
- **Quên cập nhật dữ liệu trong convertView**: dẫn đến item hiển thị sai.
- **Gọi notify sai thời điểm**: nên cập nhật dữ liệu xong mới gọi notify.
- **Dùng adapterPosition không an toàn**: luôn kiểm tra `NO_POSITION`.
- **Xử lý nặng trong onBindViewHolder**: gây giật khi cuộn.
- **ListView trong ScrollView**: gây lỗi chiều cao, nên tránh.

## Checklist nhanh cho người mới

- Có model dữ liệu rõ ràng.
- Có layout item riêng.
- Chọn đúng loại Adapter.
- Dùng ViewHolder (ListView) hoặc ViewHolder chuẩn (RecyclerView).
- Cập nhật dữ liệu rồi gọi notify.
- Tránh xử lý nặng trong lúc bind.

## Tổng kết

Adapter là phần cốt lõi khi hiển thị danh sách trong Android. Khi nắm vững Adapter, bạn có thể xây dựng UI linh hoạt, tối ưu hiệu năng, và dễ mở rộng. Đối với dự án mới, hãy ưu tiên `RecyclerView` + `ListAdapter` + `DiffUtil` để đạt hiệu quả cao nhất.
