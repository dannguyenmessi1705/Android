# 13. Live Data

Tài liệu này dựa trên project hiện tại để giải thích cách dùng ViewModel và LiveData trong Android theo hướng dễ hiểu cho người mới bắt đầu. Ví dụ minh họa lấy trực tiếp từ các lớp `CounterViewModel`, `CounterViewModelLiveData`, `MainActivity` và layout `activity_main.xml`.

## View Model in Android

**ViewModel** là lớp thuộc kiến trúc Android Jetpack, chuyên quản lý dữ liệu giao diện (UI state) và logic hiển thị. Điểm chính:

- **Tồn tại xuyên vòng đời**: ViewModel sống qua các thay đổi cấu hình (xoay màn hình, đổi theme). Activity/Fragment bị tạo lại nhưng ViewModel vẫn giữ dữ liệu.
- **Tách logic khỏi UI**: Activity/Fragment chỉ lo hiển thị, ViewModel lo dữ liệu và nghiệp vụ.
- **Không giữ tham chiếu đến View/Context**: tránh rò rỉ bộ nhớ.

Ví dụ trong project:

```kotlin
class CounterViewModel : ViewModel() {
    private var counter = 0

    fun getCounter(): Int {
        return counter
    }

    fun incrementCounter() {
        counter++
    }
}
```

Ở đây `CounterViewModel` giữ giá trị `counter` và cung cấp hàm tăng, đảm bảo dữ liệu không bị mất khi xoay màn hình. Khi Activity/Fragment bị hủy vĩnh viễn, `ViewModel.onCleared()` sẽ được gọi để giải phóng tài nguyên (nếu có).

## Adding View Model to Apps

Để thêm ViewModel vào app, cần các bước cơ bản sau:

### 1) Thêm dependency

Trong `app/build.gradle.kts` đã có:

```kotlin
val lifecycle_version = "2.10.0"
implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:${lifecycle_version}")
```

### 2) Tạo lớp ViewModel

Kế thừa từ `ViewModel` và đặt logic/dữ liệu vào bên trong (ví dụ `CounterViewModel` ở trên).

### 3) Lấy ViewModel trong Activity/Fragment

Trong `MainActivity`:

```kotlin
counterViewModel = ViewModelProvider(this)
    .get(CounterViewModel::class.java)
```

Giải thích nhanh:

- `this` là scope theo Activity, nghĩa là ViewModel tồn tại miễn Activity còn sống.
- Nếu dùng Fragment, có thể dùng `ViewModelProvider(this)` (scope theo Fragment) hoặc `ViewModelProvider(requireActivity())` để chia sẻ ViewModel giữa các Fragment trong cùng Activity.

### 4) Dùng ViewModel để cập nhật UI

Ví dụ cập nhật TextView thủ công:

```kotlin
binding.modelViewText.text = counterViewModel.getCounter().toString()
binding.viewModelBtn.setOnClickListener {
    counterViewModel.incrementCounter()
    binding.modelViewText.text = counterViewModel.getCounter().toString()
}
```

Nhược điểm: phải tự gọi cập nhật UI sau mỗi lần dữ liệu đổi. Đây là lý do LiveData ra đời.

## What's Live Data?

**LiveData** là một lớp dữ liệu có thể quan sát (observable), tự động cập nhật UI khi dữ liệu thay đổi và **nhận biết vòng đời** (lifecycle-aware).

Ưu điểm chính:

- **Tự động cập nhật UI** khi dữ liệu đổi.
- **An toàn vòng đời**: chỉ cập nhật khi Activity/Fragment ở trạng thái phù hợp (STARTED/RESUMED).
- **Giảm code cập nhật thủ công**.

Phân biệt:

- `LiveData<T>`: chỉ đọc, dùng cho View quan sát.
- `MutableLiveData<T>`: có thể thay đổi giá trị, dùng trong ViewModel.

### Thêm dependency LiveData

Trong `app/build.gradle.kts` (đã có trong project):

```kotlin
val lifecycle_version = "2.10.0"
implementation("androidx.lifecycle:lifecycle-livedata-ktx:${lifecycle_version}")
```

Nên dùng cùng phiên bản với ViewModel để tránh xung đột.

Ví dụ trong project:

```kotlin
class CounterViewModelLiveData : ViewModel() {
    var counter = MutableLiveData<Int>()

    init {
        counter.value = 0
    }

    fun incrementCounter(view: View) {
        counter.value = (counter.value ?: 0) + 1
    }
}
```

Trong thực tế, nên **ẩn MutableLiveData** để tránh UI tự ý thay đổi dữ liệu:

```kotlin
private val _counter = MutableLiveData(0)
val counter: LiveData<Int> get() = _counter
```

Sau đó mọi cập nhật chỉ diễn ra bên trong ViewModel.

### setValue và postValue

- `setValue()` dùng trên **main thread**.
- `postValue()` dùng khi cập nhật từ **background thread** (LiveData tự chuyển về main thread).

Ví dụ:

```kotlin
counter.value = (counter.value ?: 0) + 1 // setValue
```

### Quan sát LiveData thủ công (không dùng Data Binding)

Nếu không dùng Data Binding, bạn có thể `observe()` trực tiếp trong Activity/Fragment:

```kotlin
counterViewModelLiveData.counter.observe(this) { value ->
    binding.modelViewTextLiveData.text = value.toString()
}
```

## Live Data + View Model + Data Binding

Khi kết hợp LiveData + ViewModel + Data Binding, UI sẽ tự cập nhật mỗi khi dữ liệu đổi, không cần gọi `setText()` thủ công.

### 1) Bật Data Binding

Trong `app/build.gradle.kts`:

```kotlin
android {
    buildFeatures {
        dataBinding = true
    }
}
```

### 2) Khai báo biến trong layout

`activity_main.xml` dùng thẻ `<layout>` và khai báo biến:

```xml
<layout ...>
    <data>
        <variable
            name="liveData"
            type="com.didan.android.viewmodel.livedata.CounterViewModelLiveData" />
    </data>
    ...
</layout>
```

### 3) Gán ViewModel vào binding và set lifecycleOwner

Trong `MainActivity`:

```kotlin
binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
binding.lifecycleOwner = this

counterViewModelLiveData = ViewModelProvider(this)
    .get(CounterViewModelLiveData::class.java)

binding.liveData = counterViewModelLiveData
```

`lifecycleOwner` rất quan trọng để Data Binding có thể quan sát LiveData đúng cách. Nếu thiếu, dữ liệu có thay đổi cũng không tự cập nhật UI.

### 4) Binding dữ liệu và sự kiện trong XML

Trong layout:

```xml
<TextView
    android:text="@{liveData.counter.toString()}" />

<Button
    android:onClick="@{liveData::incrementCounter}"
    android:text="Increment ViewModel LiveData" />
```

Khi bấm nút, `incrementCounter()` tăng giá trị `counter`. LiveData phát ra giá trị mới, Data Binding tự động cập nhật TextView.

Luồng dữ liệu cơ bản:

1) Người dùng bấm nút trong UI.  
2) Layout gọi hàm `incrementCounter()` trong ViewModel.  
3) ViewModel cập nhật `MutableLiveData`.  
4) LiveData thông báo thay đổi tới Data Binding.  
5) Data Binding tự cập nhật TextView.

### Lưu ý cho người mới

- Nếu quên `binding.lifecycleOwner = this` thì LiveData sẽ không cập nhật UI.
- Nên khởi tạo giá trị mặc định cho LiveData (`counter.value = 0`) để tránh `null`.
- ViewModel không nên giữ `View` hoặc `Context` trực tiếp để tránh memory leak.
- Nếu LiveData có thể `null`, nên dùng `@{String.valueOf(liveData.counter)}` để tránh crash khi toString.

### Gợi ý mở rộng

- Dùng `observe()` trong Activity/Fragment nếu không dùng Data Binding.
- Tách logic phức tạp ra Repository để ViewModel chỉ giữ UI state.
