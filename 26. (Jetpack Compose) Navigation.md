# 26. (Jetpack Compose) Navigation

Tài liệu này hướng dẫn Navigation trong Jetpack Compose theo mức từ cơ bản đến nâng cao, bám theo project hiện tại và mở rộng thêm các kỹ thuật thực tế.

## Bối cảnh project hiện tại

Project đang dùng:

- Kotlin `2.3.10`
- Compose BOM `2026.02.00`
- Navigation Compose `2.9.7`
- Min SDK `24`

Trong `app/build.gradle.kts`, dependency Navigation đã có sẵn:

```kotlin
implementation(libs.androidx.navigation.compose)
```

---

## 1) Adding Nav Library

Nếu tạo project mới, thêm Navigation Compose theo version catalog như sau.

### `gradle/libs.versions.toml`

```toml
[versions]
navigationCompose = "2.9.7"

[libraries]
androidx-navigation-compose = { module = "androidx.navigation:navigation-compose", version.ref = "navigationCompose" }
```

### `app/build.gradle.kts`

```kotlin
dependencies {
    implementation(libs.androidx.navigation.compose)
}
```

Sau đó sync Gradle.

Lưu ý import đúng:

```kotlin
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
```

---

## 2) Designing the Screens

Trước khi code điều hướng, nên thiết kế 3 thứ:

- Danh sách màn hình (ví dụ: `First`, `Second`, `Profile`)
- Dữ liệu mỗi màn hình cần nhận
- Chiều điều hướng: đi tới đâu, quay lại thế nào

Ví dụ route đơn giản:

```kotlin
object Routes {
    const val FIRST = "first"
    const val SECOND = "second/{userName}?userAge={userAge}"

    fun toSecond(userName: String, userAge: String?) =
        "second/$userName" + (userAge?.let { "?userAge=$it" } ?: "")
}
```

Mẹo cho người mới:

- Tên route viết rõ nghĩa, thống nhất (snake/kebab/camel đều được, miễn đồng nhất)
- Tách hàm build route (`toSecond(...)`) để tránh ghép chuỗi rải rác
- Nếu chuỗi có khoảng trắng/ký tự đặc biệt, nên `Uri.encode(...)`

---

## 3) Nav Controllers

`NavController` là "bộ não" của Navigation:

- `navigate(route)`: đi tới màn hình mới
- `navigateUp()`: quay lại màn trước
- `popBackStack()`: pop stack có kiểm soát

Tạo controller ở composable gốc:

```kotlin
@Composable
fun AppRoot() {
    val navController = rememberNavController()
    AppNavGraph(navController = navController)
}
```

Không nên tạo nhiều `rememberNavController()` ở nhiều nơi nếu app chỉ có 1 luồng điều hướng chính.

---

## 4) Nav Host

`NavHost` là nơi khai báo graph điều hướng và màn hình khởi đầu.

```kotlin
@Composable
fun AppNavGraph(navController: NavHostController) {
    NavHost(
        navController = navController,
        startDestination = Routes.FIRST
    ) {
        composable(Routes.FIRST) {
            FirstScreen(navController = navController)
        }

        composable(
            route = Routes.SECOND,
            arguments = listOf(
                navArgument("userName") { type = NavType.StringType },
                navArgument("userAge") {
                    type = NavType.StringType
                    nullable = true
                    defaultValue = "30"
                }
            )
        ) { backStackEntry ->
            val userName = backStackEntry.arguments?.getString("userName").orEmpty()
            val userAge = backStackEntry.arguments?.getString("userAge")

            SecondScreen(
                navController = navController,
                userName = userName,
                userAge = userAge
            )
        }
    }
}
```

---

## 5) Nav Destinations

`Destination` là từng điểm đến trong graph. Có 2 cách phổ biến:

- Dùng chuỗi route trực tiếp (nhanh, dễ hiểu với người mới)
- Dùng sealed class/object để gom route tập trung (dễ maintain khi app lớn)

Ví dụ sealed class:

```kotlin
sealed class Destination(val route: String) {
    data object First : Destination("first")
    data object Second : Destination("second/{userName}?userAge={userAge}")

    companion object {
        fun second(userName: String, userAge: String?) =
            "second/$userName" + (userAge?.let { "?userAge=$it" } ?: "")
    }
}
```

Khi project lớn, cách này giảm typo và dễ refactor hơn.

---

## 6) Passing Data Between Screens

Cách cơ bản nhất: truyền qua route string.

### Màn hình gửi dữ liệu

```kotlin
val safeName = Uri.encode(enteredName)
val safeAge = Uri.encode(enteredAge)
navController.navigate("second/$safeName?userAge=$safeAge")
```

### Màn hình nhận dữ liệu

```kotlin
val userName = backStackEntry.arguments?.getString("userName").orEmpty()
val userAge = backStackEntry.arguments?.getString("userAge")
```

Khuyến nghị:

- Luôn encode dữ liệu kiểu text tự do (`Uri.encode`) trước khi navigate
- Validate dữ liệu ở màn nhận (rỗng, null, sai format)

---

## 7) Passing Multiple Arguments

Ví dụ truyền nhiều tham số cùng lúc:

```kotlin
route = "detail/{id}?tab={tab}&sort={sort}"
```

Khai báo arguments:

```kotlin
composable(
    route = "detail/{id}?tab={tab}&sort={sort}",
    arguments = listOf(
        navArgument("id") { type = NavType.IntType },
        navArgument("tab") {
            type = NavType.StringType
            defaultValue = "overview"
        },
        navArgument("sort") {
            type = NavType.StringType
            defaultValue = "newest"
        }
    )
) { entry ->
    val id = entry.arguments?.getInt("id") ?: 0
    val tab = entry.arguments?.getString("tab").orEmpty()
    val sort = entry.arguments?.getString("sort").orEmpty()
}
```

Điều hướng:

```kotlin
navController.navigate("detail/10?tab=comments&sort=top")
```

---

## 8) Passing Optional Arguments

Optional argument thường đặt ở query (`?key={key}`), có `defaultValue` hoặc `nullable = true`.

```kotlin
composable(
    route = "profile/{userId}?showPosts={showPosts}",
    arguments = listOf(
        navArgument("userId") { type = NavType.StringType },
        navArgument("showPosts") {
            type = NavType.BoolType
            defaultValue = true
        }
    )
) { entry ->
    val userId = entry.arguments?.getString("userId").orEmpty()
    val showPosts = entry.arguments?.getBoolean("showPosts") ?: true
}
```

Khi không truyền `showPosts`, giá trị mặc định được dùng:

```kotlin
navController.navigate("profile/u001")
```

Khi có truyền:

```kotlin
navController.navigate("profile/u001?showPosts=false")
```

---

## 9) Passing Data Class

Bạn **không thể truyền trực tiếp object Kotlin** qua route path như truyền `String`/`Int`. Có 3 hướng xử lý:

- Tốt nhất cho production: chỉ truyền `id`, qua màn hình sau tự load lại dữ liệu
- Trung gian: truyền object qua `SavedStateHandle`
- Nâng cao: serialize object thành JSON rồi truyền qua route

### Cách A: `SavedStateHandle` (gọn, dễ dùng)

Yêu cầu build (nếu project chưa bật `Parcelize`):

```kotlin
plugins {
    id("kotlin-parcelize")
}
```

#### Bước 1: Data class

```kotlin
@Parcelize
data class UserUiModel(
    val id: String,
    val name: String,
    val age: Int
) : Parcelable
```

#### Bước 2: Gửi object trước khi navigate

```kotlin
val user = UserUiModel("u001", "Messi", 38)
navController.currentBackStackEntry
    ?.savedStateHandle
    ?.set("user_payload", user)

navController.navigate("profile")
```

#### Bước 3: Nhận object ở màn hình đích

```kotlin
val user = navController.previousBackStackEntry
    ?.savedStateHandle
    ?.get<UserUiModel>("user_payload")
```

Ưu điểm:

- Không cần nhét object dài vào URL
- Code rõ ràng hơn cho object vừa/nhỏ

Hạn chế:

- Phụ thuộc back stack state
- Với object lớn/phức tạp, truyền `id` vẫn là hướng bền vững hơn

### Cách B: JSON qua route (khi cần deep link hoặc chia sẻ route)

Yêu cầu build (nếu project chưa có serialization):

```kotlin
dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:<version>")
}
```

```kotlin
@Serializable
data class UserPayload(val id: String, val name: String, val age: Int)

val json = Json.encodeToString(UserPayload("u001", "Messi", 38))
val encoded = Uri.encode(json)
navController.navigate("profile?payload=$encoded")
```

Nhận ở màn hình đích:

```kotlin
val encoded = entry.arguments?.getString("payload").orEmpty()
val user = if (encoded.isNotEmpty()) {
    Json.decodeFromString<UserPayload>(Uri.decode(encoded))
} else {
    null
}
```

---

## Gợi ý chuẩn hóa cho project hiện tại

Để nâng cấp code hiện tại từ mức demo sang dễ maintain:

- Tách `NavGraph` ra file riêng (ví dụ `AppNavGraph.kt`)
- Tạo object/sealed class quản lý route
- Encode input trước khi navigate (`Uri.encode`)
- Giảm truyền object trực tiếp, ưu tiên truyền `id`
- Thêm unit test cho hàm build route nếu app có logic route phức tạp

---

## Tổng kết nhanh

- `NavController`: điều khiển đi/đến/quay lại
- `NavHost`: khai báo graph và màn hình bắt đầu
- `composable(route)`: định nghĩa destination
- Dữ liệu đơn giản: truyền qua argument
- Dữ liệu phức tạp (`data class`): ưu tiên truyền `id`, hoặc dùng `SavedStateHandle`/JSON khi thật sự cần
