# 26. (Jetpack Compose) Navigation

Tài liệu này hướng dẫn Navigation trong Jetpack Compose theo mức từ cơ bản đến nâng cao, bám theo project hiện tại và mở rộng thêm các kỹ thuật thực tế.

## Bối cảnh project hiện tại

Project đang dùng:

- Kotlin `2.3.10`
- Compose BOM `2026.02.00`
- Navigation Compose `2.9.7`
- Min SDK `24`

Trong `app/build.gradle.kts`, dependency Navigation đã có sẵn:

```kotlin
implementation(libs.androidx.navigation.compose)
```

---

## 1) Adding Nav Library

Nếu tạo project mới, thêm Navigation Compose theo version catalog như sau.

### `gradle/libs.versions.toml`

```toml
[versions]
navigationCompose = "2.9.7"

[libraries]
androidx-navigation-compose = { module = "androidx.navigation:navigation-compose", version.ref = "navigationCompose" }
```

### `app/build.gradle.kts`

```kotlin
dependencies {
    implementation(libs.androidx.navigation.compose)
}
```

Sau đó sync Gradle.

Lưu ý import đúng:

```kotlin
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
```

---

## 2) Designing the Screens

Trước khi code điều hướng, nên thiết kế 3 thứ:

- Danh sách màn hình (ví dụ: `First`, `Second`, `Profile`)
- Dữ liệu mỗi màn hình cần nhận
- Chiều điều hướng: đi tới đâu, quay lại thế nào

Ví dụ route đơn giản:

```kotlin
object Routes {
    const val FIRST = "first"
    const val SECOND = "second/{userName}?userAge={userAge}"

    fun toSecond(userName: String, userAge: String?) =
        "second/$userName" + (userAge?.let { "?userAge=$it" } ?: "")
}
```

Mẹo cho người mới:

- Tên route viết rõ nghĩa, thống nhất (snake/kebab/camel đều được, miễn đồng nhất)
- Tách hàm build route (`toSecond(...)`) để tránh ghép chuỗi rải rác
- Nếu chuỗi có khoảng trắng/ký tự đặc biệt, nên `Uri.encode(...)`

---

## 3) Nav Controllers

`NavController` là "bộ não" của Navigation:

- `navigate(route)`: đi tới màn hình mới
- `navigateUp()`: quay lại màn trước
- `popBackStack()`: pop stack có kiểm soát

Tạo controller ở composable gốc:

```kotlin
@Composable
fun AppRoot() {
    val navController = rememberNavController()
    AppNavGraph(navController = navController)
}
```

Không nên tạo nhiều `rememberNavController()` ở nhiều nơi nếu app chỉ có 1 luồng điều hướng chính.

---

## 4) Nav Host

`NavHost` là nơi khai báo graph điều hướng và màn hình khởi đầu.

```kotlin
@Composable
fun AppNavGraph(navController: NavHostController) {
    NavHost(
        navController = navController,
        startDestination = Routes.FIRST
    ) {
        composable(Routes.FIRST) {
            FirstScreen(navController = navController)
        }

        composable(
            route = Routes.SECOND,
            arguments = listOf(
                navArgument("userName") { type = NavType.StringType },
                navArgument("userAge") {
                    type = NavType.StringType
                    nullable = true
                    defaultValue = "30"
                }
            )
        ) { backStackEntry ->
            val userName = backStackEntry.arguments?.getString("userName").orEmpty()
            val userAge = backStackEntry.arguments?.getString("userAge")

            SecondScreen(
                navController = navController,
                userName = userName,
                userAge = userAge
            )
        }
    }
}
```

---

## 5) Nav Destinations

`Destination` là từng điểm đến trong graph. Có 2 cách phổ biến:

- Dùng chuỗi route trực tiếp (nhanh, dễ hiểu với người mới)
- Dùng sealed class/object để gom route tập trung (dễ maintain khi app lớn)

Ví dụ sealed class:

```kotlin
sealed class Destination(val route: String) {
    data object First : Destination("first")
    data object Second : Destination("second/{userName}?userAge={userAge}")

    companion object {
        fun second(userName: String, userAge: String?) =
            "second/$userName" + (userAge?.let { "?userAge=$it" } ?: "")
    }
}
```

Khi project lớn, cách này giảm typo và dễ refactor hơn.

---

## 6) Passing Data Between Screens

Cách cơ bản nhất: truyền qua route string.

### Màn hình gửi dữ liệu

```kotlin
val safeName = Uri.encode(enteredName)
val safeAge = Uri.encode(enteredAge)
navController.navigate("second/$safeName?userAge=$safeAge")
```

### Màn hình nhận dữ liệu

```kotlin
val userName = backStackEntry.arguments?.getString("userName").orEmpty()
val userAge = backStackEntry.arguments?.getString("userAge")
```

Khuyến nghị:

- Luôn encode dữ liệu kiểu text tự do (`Uri.encode`) trước khi navigate
- Validate dữ liệu ở màn nhận (rỗng, null, sai format)

---

## 7) Passing Multiple Arguments

Ví dụ truyền nhiều tham số cùng lúc:

```kotlin
route = "detail/{id}?tab={tab}&sort={sort}"
```

Khai báo arguments:

```kotlin
composable(
    route = "detail/{id}?tab={tab}&sort={sort}",
    arguments = listOf(
        navArgument("id") { type = NavType.IntType },
        navArgument("tab") {
            type = NavType.StringType
            defaultValue = "overview"
        },
        navArgument("sort") {
            type = NavType.StringType
            defaultValue = "newest"
        }
    )
) { entry ->
    val id = entry.arguments?.getInt("id") ?: 0
    val tab = entry.arguments?.getString("tab").orEmpty()
    val sort = entry.arguments?.getString("sort").orEmpty()
}
```

Điều hướng:

```kotlin
navController.navigate("detail/10?tab=comments&sort=top")
```

---

## 8) Passing Optional Arguments

Optional argument thường đặt ở query (`?key={key}`), có `defaultValue` hoặc `nullable = true`.

```kotlin
composable(
    route = "profile/{userId}?showPosts={showPosts}",
    arguments = listOf(
        navArgument("userId") { type = NavType.StringType },
        navArgument("showPosts") {
            type = NavType.BoolType
            defaultValue = true
        }
    )
) { entry ->
    val userId = entry.arguments?.getString("userId").orEmpty()
    val showPosts = entry.arguments?.getBoolean("showPosts") ?: true
}
```

Khi không truyền `showPosts`, giá trị mặc định được dùng:

```kotlin
navController.navigate("profile/u001")
```

Khi có truyền:

```kotlin
navController.navigate("profile/u001?showPosts=false")
```

---

## 9) Passing Data Class

Bạn **không thể truyền trực tiếp object Kotlin** qua route path như truyền `String`/`Int`. Có 3 hướng xử lý:

- Tốt nhất cho production: chỉ truyền `id`, qua màn hình sau tự load lại dữ liệu
- Trung gian: truyền object qua `SavedStateHandle`
- Nâng cao: serialize object thành JSON rồi truyền qua route

### Cách A: `SavedStateHandle` (gọn, dễ dùng)

Yêu cầu build (nếu project chưa bật `Parcelize`):

```kotlin
plugins {
    id("kotlin-parcelize")
}
```

#### Bước 1: Data class

```kotlin
@Parcelize
data class UserUiModel(
    val id: String,
    val name: String,
    val age: Int
) : Parcelable
```

#### Bước 2: Gửi object trước khi navigate

```kotlin
val user = UserUiModel("u001", "Messi", 38)
navController.currentBackStackEntry
    ?.savedStateHandle
    ?.set("user_payload", user)

navController.navigate("profile")
```

#### Bước 3: Nhận object ở màn hình đích

```kotlin
val user = navController.previousBackStackEntry
    ?.savedStateHandle
    ?.get<UserUiModel>("user_payload")
```

Ưu điểm:

- Không cần nhét object dài vào URL
- Code rõ ràng hơn cho object vừa/nhỏ

Hạn chế:

- Phụ thuộc back stack state
- Với object lớn/phức tạp, truyền `id` vẫn là hướng bền vững hơn

### Cách B: JSON qua route (khi cần deep link hoặc chia sẻ route)

Yêu cầu build (nếu project chưa có serialization):

```kotlin
dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:<version>")
}
```

```kotlin
@Serializable
data class UserPayload(val id: String, val name: String, val age: Int)

val json = Json.encodeToString(UserPayload("u001", "Messi", 38))
val encoded = Uri.encode(json)
navController.navigate("profile?payload=$encoded")
```

Nhận ở màn hình đích:

```kotlin
val encoded = entry.arguments?.getString("payload").orEmpty()
val user = if (encoded.isNotEmpty()) {
    Json.decodeFromString<UserPayload>(Uri.decode(encoded))
} else {
    null
}
```

---

## Gợi ý chuẩn hóa cho project hiện tại

Để nâng cấp code hiện tại từ mức demo sang dễ maintain:

- Tách `NavGraph` ra file riêng (ví dụ `AppNavGraph.kt`)
- Tạo object/sealed class quản lý route
- Encode input trước khi navigate (`Uri.encode`)
- Giảm truyền object trực tiếp, ưu tiên truyền `id`
- Thêm unit test cho hàm build route nếu app có logic route phức tạp

---

## Tổng kết nhanh

- `NavController`: điều khiển đi/đến/quay lại
- `NavHost`: khai báo graph và màn hình bắt đầu
- `composable(route)`: định nghĩa destination
- Dữ liệu đơn giản: truyền qua argument
- Dữ liệu phức tạp (`data class`): ưu tiên truyền `id`, hoặc dùng `SavedStateHandle`/JSON khi thật sự cần

---

## 10) Bottom Navigation Trong Project (Chi tiết cho người mới bắt đầu)

Mục này bám trực tiếp vào code hiện tại trong project:

- `MainActivity.kt`
- `naviagtion/NavGraph.kt`
- `naviagtion/NavRoute.kt`
- `naviagtion/NavItem.kt`
- `naviagtion/BottomNavigationBar.kt`

### 10.1) Creating UI Screens

Ở project này, mỗi màn hình UI chỉ nhận callback và dữ liệu cần thiết, không tự tự tạo `NavController`:

- `HomeScreen(navigateToProfile, navigateToSettings)`
- `ProfileScreen(id, showDetails, navigateToSettings)`
- `SettingsScreen(navigateToHome)`

Cách làm này giúp:

- Màn hình dễ preview/test hơn.
- Tách rõ phần hiển thị UI và phần điều hướng.
- Người mới học dễ đọc vì data flow rõ ràng.

### 10.2) Nav Graph Builder

`NavGraph` hiện tại dùng `NavHost(...)` và tách các hàm:

- `addHomeScreen(...)`
- `addProfileScreen(...)`
- `addSettingsScreen(...)`

Điểm mạnh của cách tách này:

- Dễ mở rộng khi có thêm destination.
- Mỗi destination có route + argument riêng, dễ debug.
- Tránh 1 file `NavHost` quá dài.

Ví dụ khai báo `Profile` trong graph:

```kotlin
navGraphBuilder.composable(
    route = NavRoute.Profile.path.plus("/{id}/{showDetails}"),
    arguments = listOf(
        navArgument(NavRoute.Profile.id) { type = NavType.IntType },
        navArgument(NavRoute.Profile.showDetails) { type = NavType.BoolType }
    )
) { navBackStackEntry ->
    // đọc args rồi render ProfileScreen
}
```

### 10.3) Navigation Builder

Trong `BottomNavigationBar`, bạn đã dùng đúng builder cho app nhiều tab:

```kotlin
navController.navigate(route) {
    navController.graph.startDestinationRoute?.let { route ->
        popUpTo(route) { saveState = true }
    }
    launchSingleTop = true
    restoreState = true
}
```

Giải thích dễ hiểu:

- `popUpTo(start)` + `saveState`: giữ stack gọn và lưu trạng thái tab cũ.
- `launchSingleTop`: bấm lại tab hiện tại không tạo thêm instance.
- `restoreState`: quay lại tab cũ sẽ giữ được trạng thái trước đó (ví dụ scroll/list).

### 10.4) Creating Nav Routes

`NavRoute` hiện tại:

```kotlin
sealed class NavRoute(val path: String) {
    object Home : NavRoute("home")
    object Profile : NavRoute("profile") {
        val id = "id"
        val showDetails = "showDetails"
    }
    object Settings : NavRoute("settings")
}
```

Để tránh hardcode ở nhiều nơi, nên nâng lên kiểu có `pattern` + `createRoute`:

```kotlin
object Profile : NavRoute("profile") {
    const val ARG_ID = "id"
    const val ARG_SHOW_DETAILS = "showDetails"
    const val pattern = "$path/{$ARG_ID}/{$ARG_SHOW_DETAILS}"

    fun createRoute(id: Int, showDetails: Boolean): String {
        return "$path/$id/$showDetails"
    }
}
```

### 10.5) Navigating Between Routes

Luồng điều hướng thực tế đang có:

- `Home -> Profile(77, true)`
- `Home -> Settings`
- `Profile -> Settings`
- `Settings -> Home`

Ví dụ từ `HomeScreen` callback:

```kotlin
navigateToProfile = { id, showDetails ->
    navHostController.navigate(NavRoute.Profile.path.plus("/$id/$showDetails"))
}
```

Nâng cấp nên làm:

```kotlin
navigateToProfile = { id, showDetails ->
    navHostController.navigate(NavRoute.Profile.createRoute(id, showDetails))
}
```

### 10.6) Nav Controller

`NavController` được tạo 1 lần ở `MainActivity`:

```kotlin
val navHostController = rememberNavController()
```

Sau đó truyền cùng controller cho:

- `BottomNavigationBar(navController = navHostController)`
- `NavGraph(navHostController = navHostController)`

Đây là điểm rất quan trọng để NavBar và màn hình hiện tại luôn đi cùng 1 nguồn trạng thái.

### 10.7) Defining Other Destinations

Ngoài 3 tab chính, có thể thêm destination phụ không nằm trên NavBar, ví dụ `Detail`:

```kotlin
object Detail : NavRoute("detail") {
    const val ARG_ID = "id"
    const val pattern = "$path/{$ARG_ID}"
    fun createRoute(id: Long) = "$path/$id"
}
```

Khai báo trong graph:

```kotlin
composable(
    route = Detail.pattern,
    arguments = listOf(navArgument(Detail.ARG_ID) { type = NavType.LongType })
) { entry ->
    val id = entry.arguments?.getLong(Detail.ARG_ID) ?: -1L
    DetailScreen(id = id)
}
```

Destination phụ thường được mở từ 1 tab chính, nhưng không nhất thiết phải xuất hiện ở BottomNavigation.

### 10.8) Passing Arguments between Screens

Project hiện tại truyền args vào `Profile` qua path segment:

- Route pattern: `profile/{id}/{showDetails}`
- Args type: `Int`, `Boolean`

Khai báo kiểu trong `navArgument` là đúng hướng.

Điểm cần sửa để tránh crash:

```kotlin
val args = navBackStackEntry.arguments
val id = args?.getInt(NavRoute.Profile.id) ?: 0
val showDetails = args?.getBoolean(NavRoute.Profile.showDetails) ?: false
```

Tránh dùng `!!` vì dễ crash khi route không hợp lệ.

### 10.9) Nav Bottom Items

`NavItem` là model dữ liệu cho từng tab, gồm:

- `path`
- `title`
- `icon`

Hiện tại:

```kotlin
val navItems = listOf(
    NavItem.Home,
    NavItem.Profile,
    NavItem.Settings
)
```

Quy tắc tốt:

- `path` của tab nên là route gốc (`home`, `profile`, `settings`).
- Không nhét sẵn args vào `NavItem`, vì args thay đổi theo ngữ cảnh runtime.

### 10.10) Navigation Bar

Thanh dưới hiện dùng `NavigationBar` + `NavigationBarItem` của Material 3.

Cấu trúc chuẩn:

```kotlin
NavigationBar {
    navItems.forEachIndexed { index, item ->
        NavigationBarItem(
            selected = selectedItem == index,
            onClick = { /* navigate */ },
            icon = { Icon(item.icon, contentDescription = item.title) },
            label = { Text(item.title) }
        )
    }
}
```

Khi kết hợp cùng `launchSingleTop + restoreState`, UX chuyển tab sẽ mượt và ít lỗi back stack.

### 10.11) Passing Args in Nav Bar

Vì tab `Profile` cần args, code hiện tại xử lý riêng trong `onClick`:

```kotlin
val route = if (item.path == NavRoute.Profile.path) {
    NavRoute.Profile.path.plus("/77/true")
} else {
    item.path
}
```

Nên thay bằng hàm builder để dễ bảo trì:

```kotlin
val route = if (item.path == NavRoute.Profile.path) {
    NavRoute.Profile.createRoute(id = 77, showDetails = true)
} else {
    item.path
}
```

Nếu args theo user login hiện tại, lấy từ `ViewModel`/`State` trước khi build route.

### 10.12) Synchronization between NavBar & Current Screen

Đồng bộ tab đang chọn đang dùng:

```kotlin
val navBackStackEntry by navController.currentBackStackEntryAsState()
val currentRoute = navBackStackEntry?.destination?.route
val selectedItem = navItems.indexOfFirst { it.path == currentRoute }
```

Vấn đề:

- `currentRoute` của Profile có thể là `profile/{id}/{showDetails}`.
- Trong khi path của tab Profile chỉ là `profile`.
- So sánh `==` có thể làm tab không highlight đúng.

Cách ổn định hơn:

```kotlin
val selectedItem = navItems.indexOfFirst { item ->
    when (item.path) {
        NavRoute.Profile.path -> currentRoute?.startsWith(NavRoute.Profile.path) == true
        else -> item.path == currentRoute
    }
}
```

Kết quả mong muốn:

- Đang ở màn hình Profile (kể cả có args) thì tab Profile luôn sáng đúng.
- Chuyển tab nhiều lần không tạo stack quá sâu.
- Trạng thái mỗi tab được giữ khi quay lại.

### 10.13) Checklist nhanh để tự kiểm tra Bottom Navigation

- Dùng 1 `rememberNavController()` duy nhất cho luồng chính.
- `NavHost` và `BottomNavigationBar` dùng cùng `NavController`.
- Tab click dùng `navigate { popUpTo + saveState + launchSingleTop + restoreState }`.
- Route có args nên có hàm `createRoute(...)`.
- Parse args có fallback, không dùng `!!`.
- Logic selected tab xử lý được route động (`startsWith` hoặc `hierarchy`).

