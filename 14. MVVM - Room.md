# 14. MVVM - Room (ContactManagerApp)

Tài liệu này dựa trên cấu trúc hiện tại của project `ContactManagerApp` và giải thích chi tiết từng thành phần trong kiến trúc MVVM kết hợp Room. Mục tiêu là giúp người mới bắt đầu hiểu luồng dữ liệu, cách tổ chức code và cách kết nối UI với dữ liệu.

## What's MVVM

MVVM (Model - View - ViewModel) là kiến trúc phân tách trách nhiệm:
- **Model**: lớp dữ liệu và lớp truy cập dữ liệu (Room, Repository).
- **View**: giao diện XML, Activity/Fragment.
- **ViewModel**: lớp trung gian giữ trạng thái UI, gọi Repository và cung cấp dữ liệu cho View qua LiveData.

Lợi ích chính: dễ kiểm thử, giảm phụ thuộc UI vào dữ liệu, dữ liệu tồn tại qua thay đổi cấu hình (xoay màn hình).

Sơ đồ luồng dữ liệu (rút gọn):

```
UI (XML/Activity)
   |  (Data Binding, click)
   v
ViewModel
   |  (LiveData / MutableLiveData)
   v
Repository
   |  (suspend functions)
   v
Room (DAO -> Database -> SQLite)
```

Điểm quan trọng:
- View **không** chứa logic truy cập dữ liệu; chỉ hiển thị và nhận input.
- ViewModel **không** giữ tham chiếu tới View/Context để tránh leak.
- Dữ liệu đi theo 1 chiều: UI -> ViewModel -> Repository -> Room -> UI (qua LiveData).
- State UI nên đặt trong ViewModel để không mất khi xoay màn hình.

## ROOM Dependency & Annotation Processors

Room cần 2 phần: runtime (để chạy) và compiler (để sinh code).

Trong project này dùng **KAPT**:

```kotlin
plugins {
    id("kotlin-kapt")
}

dependencies {
    val room_version = "2.8.4"
    implementation("androidx.room:room-runtime:$room_version")
    kapt("androidx.room:room-compiler:$room_version")
    implementation("androidx.room:room-ktx:$room_version")
}
```

Giải thích:
- `room-runtime`: core của Room.
- `room-compiler`: annotation processor để tạo code DB/DAO.
- `room-ktx`: hỗ trợ coroutines.

Nếu muốn dùng **KSP**, bạn thay `kapt` bằng `ksp` và bật plugin KSP (project hiện đang dùng KAPT).

Điểm quan trọng:
- Phiên bản `room-compiler` phải **khớp** với `room-runtime`.
- Nếu build lỗi kiểu `Cannot find implementation`, thường do thiếu KAPT/KSP.
- Không dùng đồng thời KAPT và KSP cho Room trong cùng module.

## Entity Class

Entity đại diện cho một bảng trong DB. File hiện có:
`app/src/main/java/com/didan/android/mvvmroom/contactmanagerapp/room/Contact.kt`

```kotlin
@Entity(tableName = "contacts_table")
data class Contact(
    @PrimaryKey(autoGenerate = true)
    val contact_id: Int,
    var contact_name: String,
    var contact_email: String
)
```

Điểm cần nhớ:
- `@Entity`: tạo bảng.
- `@PrimaryKey(autoGenerate = true)`: tự tăng ID.
- Dùng `data class` để tiện so sánh và sao chép.

Điểm quan trọng:
- Trường primary key **không được null**.
- Đặt tên cột rõ ràng bằng `@ColumnInfo` nếu muốn khác tên biến.
- Dùng `@Ignore` để bỏ qua field không lưu DB.
- Nên cân nhắc `index = true` cho cột hay tìm kiếm (khi dataset lớn).

## Data Access Object

DAO định nghĩa các thao tác CRUD. File:
`app/src/main/java/com/didan/android/mvvmroom/contactmanagerapp/room/ContactDAO.kt`

```kotlin
@Dao
interface ContactDAO {
    @Insert
    suspend fun insertContact(contact: Contact): Long

    @Update
    suspend fun updateContact(contact: Contact)

    @Delete
    suspend fun deleteContact(contact: Contact)

    @Query("DELETE FROM contacts_table")
    suspend fun deleteAll()

    @Query("SELECT * FROM contacts_table")
    fun getAllContactsInDB(): LiveData<List<Contact>>
}
```

Ghi chú:
- `suspend` để chạy với coroutine, tránh chặn UI.
- `LiveData` tự động cập nhật UI khi dữ liệu thay đổi.

Điểm quan trọng:
- Có thể thêm `@Insert(onConflict = OnConflictStrategy.REPLACE/IGNORE)` để kiểm soát xung đột.
- `@Query` hỗ trợ lọc/sắp xếp, ví dụ: `ORDER BY contact_name ASC`.
- Trả về `LiveData`/`Flow` thì **không cần** `suspend`.

## Creating Database

Database khai báo danh sách Entity và cung cấp DAO.
File: `app/src/main/java/com/didan/android/mvvmroom/contactmanagerapp/room/ContactDatabase.kt`

```kotlin
@Database(entities = [Contact::class], version = 1, exportSchema = false)
abstract class ContactDatabase : RoomDatabase() {
    abstract val contactDAO: ContactDAO
}
```

`@Database` giúp Room tạo implementation tự động khi build.

Điểm quan trọng:
- Khi thay đổi schema, cần tăng `version` và thêm `Migration`.
- `exportSchema = true` giúp lưu schema để kiểm soát thay đổi (thích hợp cho team).

## Singleton Database

Để tránh tạo nhiều DB instance, dùng Singleton:

```kotlin
companion object {
    @Volatile
    private var INSTANCE: ContactDatabase? = null

    fun getInstance(context: Context): ContactDatabase {
        synchronized(this) {
            var instance = INSTANCE
            if (instance == null) {
                instance = Room.databaseBuilder(
                    context.applicationContext,
                    ContactDatabase::class.java,
                    "contacts_db"
                ).build()
            }
            INSTANCE = instance
            return instance
        }
    }
}
```

`@Volatile` + `synchronized` đảm bảo an toàn khi nhiều luồng truy cập.

Điểm quan trọng:
- Luôn dùng `applicationContext` để tránh rò rỉ Activity.
- Chỉ tạo 1 DB instance cho toàn bộ app để ổn định hiệu năng.

## Repository

Repository là lớp trung gian giữa ViewModel và DAO.
File: `app/src/main/java/com/didan/android/mvvmroom/contactmanagerapp/repository/ContactRepository.kt`

```kotlin
class ContactRepository(private val contactDAO: ContactDAO) {
    val contacts = contactDAO.getAllContactsInDB()

    suspend fun insert(contact: Contact) = contactDAO.insertContact(contact)
    suspend fun update(contact: Contact) = contactDAO.updateContact(contact)
    suspend fun delete(contact: Contact) = contactDAO.deleteContact(contact)
    suspend fun deleteAll() = contactDAO.deleteAll()
}
```

Lý do cần Repository:
- Dễ thay đổi nguồn dữ liệu (Room, API, cache).
- ViewModel không phụ thuộc vào Room trực tiếp.

Điểm quan trọng:
- Repository là “single source of truth” để thống nhất dữ liệu.
- Dễ mock Repository khi viết test cho ViewModel.

## View Model with Live Data

ViewModel cung cấp dữ liệu và hành động cho UI. File:
`app/src/main/java/com/didan/android/mvvmroom/contactmanagerapp/viewmodel/ContactViewModel.kt`

```kotlin
class ContactViewModel(private val repository: ContactRepository) : ViewModel(), Observable {
    val contacts = repository.contacts
}
```

`contacts` là `LiveData<List<Contact>>` nên UI tự động cập nhật khi DB đổi.

Điểm quan trọng:
- Tránh lưu `Context` trong ViewModel.
- ViewModel nên chỉ chứa state và thao tác liên quan đến dữ liệu.

## Mutable Live Data

`MutableLiveData` dùng cho dữ liệu có thể thay đổi từ UI:

```kotlin
@Bindable val inputName = MutableLiveData<String?>()
@Bindable val inputEmail = MutableLiveData<String?>()
@Bindable val saveOrUpdateButtonText = MutableLiveData<String>()
@Bindable val clearAllOrDeleteButtonText = MutableLiveData<String>()
```

Trong layout, dùng 2-way binding:

```xml
android:text="@={contactViewModel.inputName}"
```

Khi người dùng nhập, dữ liệu cập nhật vào ViewModel, và ngược lại.

Điểm quan trọng:
- `MutableLiveData` nên có giá trị mặc định để tránh null.
- Dùng `setValue()` trên main thread, `postValue()` khi ở background.

## Coroutines with View Model

Room cần chạy trên background thread. ViewModel dùng `viewModelScope`:

```kotlin
fun insert(contact: Contact) = viewModelScope.launch {
    repository.insert(contact)
}
```

Ưu điểm:
- Tự hủy coroutine khi ViewModel bị destroy.
- Tránh memory leak.

Điểm quan trọng:
- Với tác vụ nặng, nên dùng `Dispatchers.IO`.
- Tránh `GlobalScope` vì không bị quản lý vòng đời.

## Observable Callbacks

ViewModel hiện implement `Observable`, nhưng callback trống:

```kotlin
override fun addOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback?) {}
override fun removeOnPropertyChangedCallback(callback: Observable.OnPropertyChangedCallback?) {}
```

Vì dự án dùng `LiveData` nên không cần manual callbacks. Đây là cách đơn giản khi dùng Data Binding kết hợp LiveData.

Điểm quan trọng:
- Nếu dùng `BaseObservable`, phải gọi `notifyPropertyChanged()` thủ công.
- Với LiveData, Data Binding đã tự quan sát nên callback trống là hợp lý.

## Creating The View

View trong project là `activity_main.xml` và `card_item.xml`.

- `activity_main.xml`: chứa input, button, RecyclerView.
- `card_item.xml`: layout cho từng item trong danh sách.

UI tuân theo MVVM:
- View không gọi Room trực tiếp.
- View chỉ giao tiếp với ViewModel.

Điểm quan trọng:
- Phải bật `dataBinding = true` trong `build.gradle.kts`.
- Root layout bắt buộc là `<layout>` để dùng Data Binding.

## Data Binding with View Model

Khai báo data binding trong layout:

```xml
<layout ...>
    <data>
        <variable
            name="contactViewModel"
            type="com.didan.android.mvvmroom.contactmanagerapp.viewmodel.ContactViewModel" />
    </data>
    ...
</layout>
```

Trong Activity:

```kotlin
binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
binding.contactViewModel = contactViewModel
binding.lifecycleOwner = this
```

`lifecycleOwner` giúp Data Binding tự quan sát LiveData.

Điểm quan trọng:
- Thiếu `lifecycleOwner` sẽ làm LiveData không cập nhật UI.
- `@={}` là two-way binding, chỉ dùng khi cần cập nhật ngược ViewModel.

## Main Activity UI

`MainActivity` khởi tạo các thành phần chính:

```kotlin
val dao = ContactDatabase.getInstance(applicationContext).contactDAO
val repository = ContactRepository(dao)
val factory = ViewModelFactory(repository)
contactViewModel = ViewModelProvider(this, factory)[ContactViewModel::class.java]
```

Và thiết lập RecyclerView + observe danh sách:

```kotlin
contactViewModel.contacts.observe(this) { list ->
    binding.recyclerView.adapter = MyRecyclerViewAdapter(
        list,
        { selectItem -> listItemClicked(selectItem) }
    )
}
```

Điểm quan trọng:
- `ViewModelProvider` đảm bảo ViewModel sống sót qua rotate.
- Nếu dùng Fragment, nên scope ViewModel theo Fragment/Activity tùy nhu cầu.

## Data Binding with RecyclerView

Adapter hiện tại dùng Data Binding để inflate item:

```kotlin
val binding: CardItemBinding = DataBindingUtil.inflate(
    layoutInflater,
    R.layout.card_item,
    parent,
    false
)
```

`bind()` gán dữ liệu Contact vào TextView:

```kotlin
binding.nameTextView.text = contact.contact_name
binding.emailTextView.text = contact.contact_email
```

Bạn có thể nâng cao bằng cách tạo `@BindingAdapter` để gán dữ liệu trực tiếp từ XML, nhưng phiên bản hiện tại đủ cho người mới bắt đầu.

Điểm quan trọng:
- Với danh sách lớn, dùng `ListAdapter + DiffUtil` để update mượt.
- Tránh tạo Adapter mới mỗi lần nếu dataset lớn, thay bằng update list.

## Handling Click Events

Trong layout, click nút được gọi thẳng vào ViewModel:

```xml
android:onClick="@{() -> contactViewModel.saveOrUpdate()}"
android:onClick="@{() -> contactViewModel.clearAllOrDelete()}"
```

Trong RecyclerView, click item được truyền qua lambda:

```kotlin
binding.listItemLayout.setOnClickListener {
    clickListener(contact)
}
```

MainActivity xử lý:

```kotlin
private fun listItemClicked(selectedItem: Contact) {
    Toast.makeText(this, "Selected Name is ${selectedItem.contact_name}", Toast.LENGTH_LONG).show()
    contactViewModel.initUpdateAndDelete(selectedItem)
}
```

Việc gọi `initUpdateAndDelete()` giúp chuyển UI sang trạng thái cập nhật/xóa.

Điểm quan trọng:
- Sự kiện một lần (Toast/Navigation) nên dùng Event wrapper để tránh lặp lại.
- ViewModel không nên tự gọi `Toast` hay tham chiếu Activity.

## View Model Factory

Vì ViewModel cần tham số `repository`, phải dùng Factory:

```kotlin
class ViewModelFactory(private val repository: ContactRepository) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(ContactViewModel::class.java)) {
            return ContactViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel Class")
    }
}
```

Factory giúp ViewModel được khởi tạo đúng cách và dễ mở rộng khi cần thêm tham số.

Điểm quan trọng:
- Khi dùng `by viewModels { factory }`, Factory giúp code gọn hơn.
- Với nhiều dependency phức tạp, cân nhắc DI (Hilt/Koin).

---

### Gợi ý mở rộng (nâng cao nhẹ)

- Thêm `validation` cho input (không cho rỗng email/name).
- Sử dụng `DiffUtil` trong RecyclerView để update mượt hơn.
- Thêm `State` hoặc `Event` để xử lý thông báo (Toast) an toàn hơn.
