# 16. Coroutines trong Android

## Mục lục

1. [Coroutines là gì?](#1-coroutines-là-gì)
2. [Sử dụng Main Thread (UI Thread)](#2-sử-dụng-main-thread-ui-thread)
3. [Tạo Coroutine đầu tiên](#3-tạo-coroutine-đầu-tiên)
4. [Các Scopes trong Coroutines](#4-các-scopes-trong-coroutines)
5. [Dispatchers](#5-dispatchers)
6. [Khởi chạy Coroutines](#6-khởi-chạy-coroutines)
7. [Ứng dụng Coroutines](#7-ứng-dụng-coroutines)
8. [Chuyển đổi giữa các Coroutines](#8-chuyển-đổi-giữa-các-coroutines)
9. [Suspend Functions](#9-suspend-functions)
10. [Sequential Coroutines (Coroutines tuần tự)](#10-sequential-coroutines-coroutines-tuần-tự)
11. [Parallel Coroutines (Coroutines song song)](#11-parallel-coroutines-coroutines-song-song)

---

## 1. Coroutines là gì?

### 1.1. Định nghĩa

**Coroutines** (hay còn gọi là "coroutine" - viết tắt của "cooperative routines") là một tính năng mạnh mẽ trong Kotlin cho phép bạn viết mã **bất đồng bộ (asynchronous)** một cách **tuần tự và dễ đọc**. Coroutines giúp quản lý các tác vụ chạy dài (long-running tasks) mà không làm block (chặn) luồng chính của ứng dụng.

### 1.2. Tại sao cần Coroutines?

Trong phát triển Android, có nhiều tác vụ tốn thời gian như:
- **Tải dữ liệu từ mạng** (Network requests)
- **Đọc/ghi dữ liệu vào database**
- **Xử lý file lớn**
- **Tính toán phức tạp**

Nếu thực hiện các tác vụ này trên **Main Thread (UI Thread)**, ứng dụng sẽ bị **đơ (freeze)** và có thể gây ra lỗi **ANR (Application Not Responding)**.

### 1.3. So sánh Coroutines với các phương pháp khác

| Phương pháp | Ưu điểm | Nhược điểm |
|-------------|---------|------------|
| **Thread** | Đơn giản, trực tiếp | Tốn tài nguyên, khó quản lý |
| **AsyncTask** (đã deprecated) | Dễ sử dụng | Không linh hoạt, dễ gây memory leak |
| **RxJava** | Mạnh mẽ, nhiều operator | Phức tạp, learning curve cao |
| **Coroutines** | Nhẹ, dễ đọc, tích hợp tốt với Kotlin | Cần hiểu về suspend functions |

### 1.4. Đặc điểm của Coroutines

- **Nhẹ (Lightweight)**: Có thể tạo hàng nghìn coroutines mà không lo tốn tài nguyên như Thread
- **Memory leak ít hơn**: Coroutines có thể bị hủy khi không cần thiết
- **Built-in cancellation support**: Hỗ trợ sẵn việc hủy coroutine
- **Jetpack integration**: Tích hợp tốt với các thư viện Android Jetpack

```kotlin
// Ví dụ đơn giản về Coroutines
CoroutineScope(Dispatchers.IO).launch {
    // Thực hiện công việc nặng trên background thread
    val data = fetchDataFromNetwork()
    
    withContext(Dispatchers.Main) {
        // Cập nhật UI trên Main Thread
        updateUI(data)
    }
}
```

---

## 2. Sử dụng Main Thread (UI Thread)

### 2.1. Main Thread là gì?

**Main Thread** (còn gọi là **UI Thread**) là luồng chính của ứng dụng Android, chịu trách nhiệm:
- Vẽ giao diện người dùng (UI)
- Xử lý các sự kiện tương tác (click, swipe, etc.)
- Cập nhật các View components

### 2.2. Vấn đề khi block Main Thread

Khi bạn thực hiện công việc nặng trên Main Thread, ứng dụng sẽ:

```kotlin
// ❌ KHÔNG NÊN: Làm block UI Thread
binding.downloadBtn.setOnClickListener {
    // Công việc này sẽ làm UI bị đơ
    for (i in 1..100000) {
        Log.i("TAGY", "Processing: $i")
    }
}
```

**Kết quả**: UI sẽ bị freeze, người dùng không thể tương tác với ứng dụng.

### 2.3. Quy tắc vàng trong Android

> **Chỉ có Main Thread mới được phép cập nhật UI!**

Nếu bạn cố gắng cập nhật UI từ một thread khác, ứng dụng sẽ crash với lỗi:
```
android.view.ViewRootImpl$CalledFromWrongThreadException: 
Only the original thread that created a view hierarchy can touch its views.
```

### 2.4. Ví dụ minh họa từ project

```kotlin
// ❌ SAI: Cập nhật UI từ background thread
CoroutineScope(Dispatchers.IO).launch {
    for (i in 1..100000) {
        // Lỗi! Đang ở background thread nhưng cập nhật UI
        binding.downloadTextProgress.text = "$i"
    }
}

// ✅ ĐÚNG: Chuyển về Main Thread để cập nhật UI
CoroutineScope(Dispatchers.IO).launch {
    for (i in 1..100000) {
        withContext(Dispatchers.Main) {
            binding.downloadTextProgress.text = "$i in ${Thread.currentThread().name}"
        }
    }
}
```

---

## 3. Tạo Coroutine đầu tiên

### 3.1. Thêm dependency

Trước tiên, bạn cần thêm thư viện Coroutines vào file `build.gradle.kts`:

```kotlin
dependencies {
    // Thư viện Coroutines cho Android
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9")
}
```

### 3.2. Import các thành phần cần thiết

```kotlin
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
```

### 3.3. Cấu trúc cơ bản của một Coroutine

```kotlin
CoroutineScope(Dispatchers.Main).launch {
    // Code trong coroutine sẽ được thực thi ở đây
    // Đây là code bất đồng bộ nhưng viết như code đồng bộ
}
```

**Giải thích:**
- `CoroutineScope`: Định nghĩa phạm vi (scope) của coroutine
- `Dispatchers.Main`: Chỉ định coroutine chạy trên Main Thread
- `launch`: Hàm để khởi chạy coroutine

### 3.4. Ví dụ thực tế đầu tiên

```kotlin
class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // Tạo coroutine đầu tiên
        CoroutineScope(Dispatchers.Main).launch {
            // In ra tên của thread hiện tại
            binding.counterText.text = "Hello from ${Thread.currentThread().name}"
            // Output: Hello from main
        }
    }
}
```

### 3.5. Coroutine trên Background Thread

```kotlin
// Tạo coroutine chạy trên background thread
CoroutineScope(Dispatchers.IO).launch {
    // Code này chạy trên background thread
    val result = performHeavyComputation()
    
    // Chuyển về Main Thread để cập nhật UI
    withContext(Dispatchers.Main) {
        textView.text = result
    }
}
```

---

## 4. Các Scopes trong Coroutines

### 4.1. Scope là gì?

**CoroutineScope** định nghĩa vòng đời (lifecycle) của các coroutines. Khi một scope bị hủy, tất cả các coroutines trong scope đó cũng sẽ bị hủy theo.

### 4.2. Các loại Scope phổ biến

#### 4.2.1. GlobalScope

```kotlin
GlobalScope.launch {
    // Coroutine này tồn tại trong suốt vòng đời của ứng dụng
    // ⚠️ KHÔNG KHUYẾN KHÍCH sử dụng vì có thể gây memory leak
}
```

**Đặc điểm:**
- Tồn tại trong suốt thời gian ứng dụng chạy
- Không tự động hủy khi Activity/Fragment bị destroy
- Có thể gây memory leak

#### 4.2.2. CoroutineScope tự tạo

```kotlin
// Tạo scope riêng với Dispatcher cụ thể
val myScope = CoroutineScope(Dispatchers.IO)

myScope.launch {
    // Công việc của coroutine
}

// Khi không cần nữa, hủy scope
myScope.cancel()
```

#### 4.2.3. lifecycleScope (Khuyến nghị cho Activity/Fragment)

```kotlin
// Tự động hủy khi lifecycle owner bị destroy
lifecycleScope.launch {
    // Công việc của coroutine
}
```

#### 4.2.4. viewModelScope (Khuyến nghị cho ViewModel)

```kotlin
class MyViewModel : ViewModel() {
    fun loadData() {
        viewModelScope.launch {
            // Tự động hủy khi ViewModel bị clear
            val data = repository.fetchData()
            _uiState.value = data
        }
    }
}
```

### 4.3. So sánh các Scope

| Scope | Vòng đời | Sử dụng khi |
|-------|----------|-------------|
| `GlobalScope` | Toàn ứng dụng | Hiếm khi dùng, cần thận trọng |
| `CoroutineScope` | Tùy chỉnh | Khi cần kiểm soát thủ công |
| `lifecycleScope` | Theo Activity/Fragment | Trong Activity/Fragment |
| `viewModelScope` | Theo ViewModel | Trong ViewModel |

### 4.4. Ví dụ thực tế

```kotlin
class MainActivity : AppCompatActivity() {
    
    // Tạo scope riêng
    private val mainScope = CoroutineScope(Dispatchers.Main)
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        mainScope.launch {
            // Coroutine 1
        }
        
        mainScope.launch {
            // Coroutine 2
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // Hủy tất cả coroutines khi Activity bị destroy
        mainScope.cancel()
    }
}
```

---

## 5. Dispatchers

### 5.1. Dispatcher là gì?

**Dispatcher** xác định **thread nào** sẽ thực thi coroutine. Kotlin cung cấp các Dispatcher có sẵn để phù hợp với từng loại công việc.

### 5.2. Các loại Dispatcher

#### 5.2.1. Dispatchers.Main

```kotlin
CoroutineScope(Dispatchers.Main).launch {
    // Chạy trên Main Thread (UI Thread)
    // Dùng để cập nhật UI
    binding.textView.text = "Updated from Main"
}
```

**Sử dụng khi:**
- Cập nhật UI
- Xử lý các sự kiện UI
- Hiển thị dialog, toast

#### 5.2.2. Dispatchers.IO

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    // Tối ưu cho các công việc I/O
    // Có thể sử dụng nhiều threads
    val data = fetchFromNetwork()
    val file = readFromFile()
}
```

**Sử dụng khi:**
- Gọi API network
- Đọc/ghi file
- Truy vấn database

#### 5.2.3. Dispatchers.Default

```kotlin
CoroutineScope(Dispatchers.Default).launch {
    // Tối ưu cho các công việc tính toán nặng (CPU-intensive)
    val result = performComplexCalculation()
    val sortedList = hugeList.sorted()
}
```

**Sử dụng khi:**
- Xử lý ảnh
- Sắp xếp danh sách lớn
- Tính toán phức tạp

#### 5.2.4. Dispatchers.Unconfined

```kotlin
CoroutineScope(Dispatchers.Unconfined).launch {
    // Chạy trên thread hiện tại cho đến khi gặp suspend function
    // Sau đó sẽ resume trên thread của suspend function
}
```

**⚠️ Ít sử dụng trong thực tế**

### 5.3. So sánh các Dispatcher

| Dispatcher | Thread | Sử dụng cho |
|------------|--------|-------------|
| `Main` | UI Thread | Cập nhật UI |
| `IO` | Background thread pool | Network, File, Database |
| `Default` | Background thread pool | Tính toán CPU-intensive |
| `Unconfined` | Không xác định | Testing, trường hợp đặc biệt |

### 5.4. Ví dụ thực tế từ project

```kotlin
binding.downloadBtn.setOnClickListener {
    // Sử dụng Dispatchers.IO cho công việc tải file
    CoroutineScope(Dispatchers.IO).launch {
        downloadBigFileFromNet()
    }
}

private suspend fun downloadBigFileFromNet() {
    for (i in 1..100000) {
        // Công việc nặng chạy trên IO thread
        
        // Chuyển về Main Thread để cập nhật UI
        withContext(Dispatchers.Main) {
            binding.downloadTextProgress.text = " $i in ${Thread.currentThread().name}"
        }
    }
}
```

---

## 6. Khởi chạy Coroutines

### 6.1. Sử dụng `launch`

`launch` là coroutine builder phổ biến nhất, trả về một `Job` và **không trả về kết quả**.

```kotlin
val job: Job = CoroutineScope(Dispatchers.Main).launch {
    // Thực hiện công việc
    delay(1000)
    println("Công việc hoàn thành!")
}

// Có thể hủy job khi cần
job.cancel()
```

**Đặc điểm:**
- Fire-and-forget (chạy và không cần biết kết quả)
- Trả về `Job` để quản lý coroutine
- Không block thread gọi

### 6.2. Sử dụng `async`

`async` là coroutine builder trả về `Deferred<T>`, cho phép **nhận kết quả** từ coroutine.

```kotlin
val deferred: Deferred<String> = CoroutineScope(Dispatchers.IO).async {
    // Thực hiện công việc và trả về kết quả
    delay(1000)
    return@async "Kết quả từ async"
}

// Lấy kết quả bằng await()
val result = deferred.await()
println(result) // "Kết quả từ async"
```

**Đặc điểm:**
- Trả về `Deferred<T>` chứa kết quả
- Sử dụng `await()` để lấy kết quả
- Phù hợp khi cần kết quả từ coroutine

### 6.3. So sánh `launch` vs `async`

| Đặc điểm | launch | async |
|----------|--------|-------|
| Kiểu trả về | `Job` | `Deferred<T>` |
| Có kết quả | Không | Có |
| Sử dụng khi | Fire-and-forget | Cần kết quả |

### 6.4. Ví dụ thực tế

```kotlin
class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Sử dụng launch cho cập nhật UI
        CoroutineScope(Dispatchers.Main).launch {
            binding.counterText.text = "Hello from ${Thread.currentThread().name}"
        }
        
        // Sử dụng async khi cần kết quả
        CoroutineScope(Dispatchers.IO).launch {
            val result = async {
                // Giả lập fetch data
                delay(1000)
                "Data from server"
            }.await()
            
            withContext(Dispatchers.Main) {
                binding.textView.text = result
            }
        }
    }
}
```

### 6.5. Sử dụng `runBlocking` (Chỉ dùng cho testing)

```kotlin
// ⚠️ KHÔNG dùng trong production code
// runBlocking sẽ block thread hiện tại
fun main() = runBlocking {
    launch {
        delay(1000)
        println("World!")
    }
    println("Hello,")
}
// Output: Hello, World!
```

---

## 7. Ứng dụng Coroutines

### 7.1. Cấu trúc project mẫu

Dựa trên project hiện tại, ta có một ứng dụng demo với:
- **Activity**: MainActivity.kt
- **Layout**: activity_main.xml
- **Chức năng**: Đếm số và giả lập tải file

### 7.2. Layout (activity_main.xml)

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/main"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity">

        <TextView
            android:id="@+id/textView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Coroutines App"
            android:textSize="28sp"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toEndOf="parent" />

        <TextView
            android:id="@+id/counterText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="0"
            android:textSize="32sp" />

        <Button
            android:id="@+id/countBtn"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Start Counting" />

        <TextView
            android:id="@+id/downloadTextProgress"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="0"
            android:textSize="46sp" />

        <Button
            android:id="@+id/downloadBtn"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Start Download" />

    </androidx.constraintlayout.widget.ConstraintLayout>
</layout>
```

### 7.3. MainActivity.kt - Code hoàn chỉnh

```kotlin
package com.didan.android.coroutines

import android.os.Bundle
import android.util.Log
import androidx.activity.enableEdgeToEdge
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.didan.android.coroutines.databinding.ActivityMainBinding
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class MainActivity : AppCompatActivity() {

    lateinit var binding: ActivityMainBinding

    private var counter: Int = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }

        // Nút đếm số - hoạt động bình thường trên UI Thread
        binding.countBtn.setOnClickListener {
            binding.counterText.text = counter++.toString()
        }
        
        // Nút tải file - sử dụng Coroutines
        binding.downloadBtn.setOnClickListener {
            // Tạo CoroutineScope với Dispatcher.IO
            CoroutineScope(Dispatchers.IO).launch {
                downloadBigFileFromNet()
            }
        }
    }

    private suspend fun downloadBigFileFromNet() {
        for (i in 1..100000) {
            // Chuyển về Dispatcher.Main để cập nhật UI
            withContext(Dispatchers.Main) {
                binding.downloadTextProgress.text = " $i in ${Thread.currentThread().name}"
            }
        }
    }
}
```

### 7.4. Kết quả

Khi chạy ứng dụng:
1. **Nút "Start Counting"**: Tăng số đếm mỗi lần click
2. **Nút "Start Download"**: Giả lập tải file từ 1 đến 100000
3. **Quan trọng**: Trong khi "tải file", nút "Start Counting" vẫn hoạt động bình thường vì tác vụ nặng chạy trên background thread

---

## 8. Chuyển đổi giữa các Coroutines

### 8.1. Sử dụng `withContext`

`withContext` cho phép chuyển đổi Dispatcher trong một coroutine mà không cần tạo coroutine mới.

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    // Đang ở IO thread
    val data = fetchDataFromNetwork() // Công việc I/O
    
    // Chuyển sang Main thread để cập nhật UI
    withContext(Dispatchers.Main) {
        textView.text = data
    }
    
    // Tự động quay lại IO thread
    saveToDatabase(data)
}
```

### 8.2. Ví dụ chi tiết

```kotlin
private suspend fun downloadBigFileFromNet() {
    for (i in 1..100000) {
        // Đang ở Dispatchers.IO (background thread)
        Log.i("TAGY", "Downloading: $i on ${Thread.currentThread().name}")
        
        // Chuyển sang Dispatchers.Main để cập nhật UI
        withContext(Dispatchers.Main) {
            binding.downloadTextProgress.text = " $i in ${Thread.currentThread().name}"
            // Output: " 12345 in main"
        }
        
        // Sau withContext, tự động quay lại Dispatchers.IO
    }
}
```

### 8.3. Nested Context Switching

```kotlin
CoroutineScope(Dispatchers.Main).launch {
    // Main Thread
    showLoadingIndicator()
    
    val result = withContext(Dispatchers.IO) {
        // IO Thread - Fetch data
        val rawData = api.fetchData()
        
        withContext(Dispatchers.Default) {
            // Default Thread - Xử lý dữ liệu nặng
            processData(rawData)
        }
    }
    
    // Quay lại Main Thread
    hideLoadingIndicator()
    displayResult(result)
}
```

### 8.4. So sánh `withContext` vs `launch`

| Đặc điểm | withContext | launch |
|----------|-------------|--------|
| Tạo coroutine mới | Không | Có |
| Suspends caller | Có | Không |
| Trả về kết quả | Có | Job |
| Sử dụng khi | Cần chuyển context tạm thời | Cần chạy song song |

---

## 9. Suspend Functions

### 9.1. Suspend Function là gì?

**Suspend function** là một hàm có thể bị **tạm dừng (suspend)** và **tiếp tục (resume)** mà không block thread. Chỉ có thể gọi suspend function từ một coroutine hoặc một suspend function khác.

```kotlin
// Khai báo suspend function bằng từ khóa "suspend"
suspend fun fetchUserData(): User {
    // Có thể sử dụng các suspend function khác
    delay(1000) // Suspend 1 giây
    return User("John", "Doe")
}
```

### 9.2. Đặc điểm của Suspend Function

1. **Không block thread**: Khi suspend, thread được giải phóng để làm việc khác
2. **Sequential code**: Code trông như đồng bộ nhưng thực tế là bất đồng bộ
3. **Chỉ gọi được từ coroutine**: Không thể gọi trực tiếp từ regular function

### 9.3. Ví dụ từ project

```kotlin
// Suspend function để download file
private suspend fun downloadBigFileFromNet() {
    for (i in 1..100000) {
        // withContext là suspend function, nên hàm này cũng phải là suspend
        withContext(Dispatchers.Main) {
            binding.downloadTextProgress.text = " $i in ${Thread.currentThread().name}"
        }
    }
}

// Gọi suspend function từ coroutine
binding.downloadBtn.setOnClickListener {
    CoroutineScope(Dispatchers.IO).launch {
        downloadBigFileFromNet() // OK - gọi từ coroutine
    }
}
```

### 9.4. Các Suspend Function phổ biến

```kotlin
// delay - tạm dừng coroutine một khoảng thời gian
suspend fun example1() {
    delay(1000) // Suspend 1 giây, không block thread
}

// withContext - chuyển context
suspend fun example2() {
    withContext(Dispatchers.IO) {
        // Thực hiện I/O operation
    }
}

// await - chờ kết quả từ Deferred
suspend fun example3() {
    val deferred = async { fetchData() }
    val result = deferred.await() // Suspend cho đến khi có kết quả
}
```

### 9.5. Tạo Suspend Function của riêng bạn

```kotlin
// Suspend function để fetch user từ API
suspend fun fetchUser(userId: String): User {
    return withContext(Dispatchers.IO) {
        // Giả lập network call
        delay(2000)
        User(userId, "John Doe", "john@email.com")
    }
}

// Suspend function để lưu user vào database
suspend fun saveUser(user: User) {
    withContext(Dispatchers.IO) {
        // Giả lập database operation
        delay(500)
        database.insert(user)
    }
}

// Sử dụng
CoroutineScope(Dispatchers.Main).launch {
    showLoading()
    
    val user = fetchUser("123") // Suspend
    saveUser(user)              // Suspend
    
    hideLoading()
    showUser(user)
}
```

---

## 10. Sequential Coroutines (Coroutines tuần tự)

### 10.1. Khái niệm

**Sequential Coroutines** là khi các coroutines được thực thi **tuần tự, lần lượt**. Coroutine sau chỉ bắt đầu khi coroutine trước hoàn thành.

### 10.2. Ví dụ cơ bản

```kotlin
CoroutineScope(Dispatchers.Main).launch {
    // Các công việc được thực hiện tuần tự
    val result1 = task1() // Hoàn thành trước
    val result2 = task2() // Sau đó mới chạy
    val result3 = task3() // Cuối cùng
    
    // Tổng thời gian = time(task1) + time(task2) + time(task3)
}
```

### 10.3. Ví dụ chi tiết

```kotlin
suspend fun fetchUserProfile(): String {
    delay(1000) // Giả lập network call 1 giây
    return "User Profile"
}

suspend fun fetchUserPosts(): String {
    delay(1500) // Giả lập network call 1.5 giây
    return "User Posts"
}

suspend fun fetchUserFriends(): String {
    delay(800) // Giả lập network call 0.8 giây
    return "User Friends"
}

// Sequential execution
fun loadUserDataSequentially() {
    CoroutineScope(Dispatchers.Main).launch {
        val startTime = System.currentTimeMillis()
        
        // Thực hiện tuần tự
        val profile = fetchUserProfile()  // 1 giây
        Log.d("COROUTINE", "Profile: $profile")
        
        val posts = fetchUserPosts()      // 1.5 giây
        Log.d("COROUTINE", "Posts: $posts")
        
        val friends = fetchUserFriends()  // 0.8 giây
        Log.d("COROUTINE", "Friends: $friends")
        
        val totalTime = System.currentTimeMillis() - startTime
        Log.d("COROUTINE", "Total time: $totalTime ms")
        // Total time ≈ 3300 ms (1000 + 1500 + 800)
    }
}
```

### 10.4. Khi nào sử dụng Sequential Coroutines?

1. **Khi có phụ thuộc dữ liệu**: Task sau cần kết quả của task trước

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    // Phải lấy userId trước
    val userId = authenticateUser(username, password)
    
    // Sau đó mới lấy được user data
    val userData = fetchUserData(userId)
    
    // Cuối cùng mới lưu vào database
    saveToLocalDb(userData)
}
```

2. **Khi cần đảm bảo thứ tự**: Các bước phải thực hiện theo thứ tự cụ thể

```kotlin
suspend fun processOrder(order: Order) {
    validateOrder(order)      // Bước 1: Validate
    reserveInventory(order)   // Bước 2: Reserve
    processPayment(order)     // Bước 3: Payment
    shipOrder(order)          // Bước 4: Ship
}
```

---

## 11. Parallel Coroutines (Coroutines song song)

### 11.1. Khái niệm

**Parallel Coroutines** là khi nhiều coroutines được thực thi **đồng thời, song song**. Điều này giúp giảm tổng thời gian thực thi khi các tasks không phụ thuộc vào nhau.

### 11.2. Sử dụng `async` để chạy song song

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    val startTime = System.currentTimeMillis()
    
    // Khởi chạy song song với async
    val profileDeferred = async { fetchUserProfile() }  // Bắt đầu ngay
    val postsDeferred = async { fetchUserPosts() }      // Bắt đầu ngay
    val friendsDeferred = async { fetchUserFriends() }  // Bắt đầu ngay
    
    // Chờ tất cả hoàn thành và lấy kết quả
    val profile = profileDeferred.await()
    val posts = postsDeferred.await()
    val friends = friendsDeferred.await()
    
    val totalTime = System.currentTimeMillis() - startTime
    Log.d("COROUTINE", "Total time: $totalTime ms")
    // Total time ≈ 1500 ms (max của 3 tasks)
}
```

### 11.3. So sánh Sequential vs Parallel

```kotlin
// ===== SEQUENTIAL =====
suspend fun loadDataSequentially() {
    val result1 = task1() // 1 giây
    val result2 = task2() // 1 giây  
    val result3 = task3() // 1 giây
    // Tổng: 3 giây
}

// ===== PARALLEL =====
suspend fun loadDataParallel() = coroutineScope {
    val deferred1 = async { task1() } // Bắt đầu ngay
    val deferred2 = async { task2() } // Bắt đầu ngay
    val deferred3 = async { task3() } // Bắt đầu ngay
    
    val result1 = deferred1.await()
    val result2 = deferred2.await()
    val result3 = deferred3.await()
    // Tổng: ~1 giây (chạy song song)
}
```

### 11.4. Ví dụ thực tế với nhiều API calls

```kotlin
data class UserDashboard(
    val profile: UserProfile,
    val posts: List<Post>,
    val notifications: List<Notification>,
    val friends: List<User>
)

suspend fun loadUserDashboard(userId: String): UserDashboard = coroutineScope {
    // Khởi chạy tất cả requests song song
    val profileDeferred = async { api.getUserProfile(userId) }
    val postsDeferred = async { api.getUserPosts(userId) }
    val notificationsDeferred = async { api.getNotifications(userId) }
    val friendsDeferred = async { api.getFriends(userId) }
    
    // Chờ tất cả hoàn thành
    UserDashboard(
        profile = profileDeferred.await(),
        posts = postsDeferred.await(),
        notifications = notificationsDeferred.await(),
        friends = friendsDeferred.await()
    )
}

// Sử dụng
CoroutineScope(Dispatchers.Main).launch {
    showLoading()
    val dashboard = loadUserDashboard("user123")
    hideLoading()
    displayDashboard(dashboard)
}
```

### 11.5. Sử dụng `awaitAll` cho nhiều async

```kotlin
suspend fun fetchAllUsers(userIds: List<String>): List<User> = coroutineScope {
    // Tạo danh sách các deferred
    val deferredList = userIds.map { userId ->
        async { fetchUser(userId) }
    }
    
    // Chờ tất cả hoàn thành
    deferredList.awaitAll()
}
```

### 11.6. Xử lý lỗi trong Parallel Coroutines

```kotlin
suspend fun loadDataWithErrorHandling() = coroutineScope {
    try {
        val deferred1 = async { 
            fetchData1() 
        }
        val deferred2 = async { 
            fetchData2() 
        }
        
        val result1 = deferred1.await()
        val result2 = deferred2.await()
        
        Pair(result1, result2)
    } catch (e: Exception) {
        Log.e("COROUTINE", "Error: ${e.message}")
        // Khi một async fail, các async khác cũng sẽ bị cancel
        null
    }
}
```

### 11.7. Sử dụng `supervisorScope` để xử lý lỗi độc lập

```kotlin
suspend fun loadDataIndependently() = supervisorScope {
    // Với supervisorScope, nếu một async fail, các async khác vẫn tiếp tục
    val deferred1 = async { 
        try {
            fetchData1()
        } catch (e: Exception) {
            null
        }
    }
    val deferred2 = async { 
        try {
            fetchData2()
        } catch (e: Exception) {
            null
        }
    }
    
    Pair(deferred1.await(), deferred2.await())
}
```

---

## Tổng kết

### Các khái niệm chính

| Khái niệm | Mô tả |
|-----------|-------|
| **Coroutines** | Công cụ để viết code bất đồng bộ một cách tuần tự |
| **Scope** | Định nghĩa vòng đời của coroutines |
| **Dispatcher** | Xác định thread thực thi coroutine |
| **launch** | Khởi chạy coroutine, không trả về kết quả |
| **async** | Khởi chạy coroutine, trả về Deferred với kết quả |
| **suspend** | Hàm có thể tạm dừng và tiếp tục |
| **withContext** | Chuyển đổi Dispatcher trong coroutine |

### Best Practices

1. **Luôn sử dụng Scope phù hợp**: `lifecycleScope` cho Activity/Fragment, `viewModelScope` cho ViewModel
2. **Chọn Dispatcher đúng**: `IO` cho I/O operations, `Main` cho UI, `Default` cho tính toán
3. **Tránh GlobalScope**: Có thể gây memory leak
4. **Sử dụng suspend functions**: Giúp code dễ đọc và bảo trì
5. **Xử lý lỗi đúng cách**: Sử dụng try-catch hoặc CoroutineExceptionHandler
6. **Chạy song song khi có thể**: Giảm thời gian chờ đợi khi các tasks độc lập

### Tài liệu tham khảo

- [Kotlin Coroutines Guide](https://kotlinlang.org/docs/coroutines-guide.html)
- [Android Coroutines Guide](https://developer.android.com/kotlin/coroutines)
- [Coroutines Codelab](https://developer.android.com/codelabs/kotlin-coroutines)

