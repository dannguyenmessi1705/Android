# 25. (Jetpack Compose) List

## 1) Mục tiêu

Tài liệu này hướng dẫn cách làm việc với **List trong Jetpack Compose** từ cơ bản đến nâng cao, dành cho người mới bắt đầu, gồm:

- Scrolling Column
- Scrolling Row
- Lazy Column
- Custom List Layout
- Lazy Row
- Sticky Headers
- Handling Click Events on Items List
- Cards

Nội dung được viết dựa trên project hiện tại (`JetpackList`) và mở rộng thêm các kỹ thuật thực tế.

---

## 2) Bối cảnh từ project hiện tại

Project đang dùng:

- Kotlin + Jetpack Compose
- Material 3
- `minSdk = 24`
- Ảnh local trong `res/drawable` (`pic1`, `pic2`, `pic3`)

Trong `MainActivity.kt` đã có sẵn các hàm:

- `ScrollingColumn()`
- `ScrollingRow()`
- `MyLazyColumn()`
- `MyLazyRow()`
- `MyCard()`

Ta sẽ chuẩn hóa và nâng cấp cách dùng cho đúng best-practice.

---

## 3) Scrolling Column

### Khi nào dùng?

Dùng khi danh sách **ngắn hoặc trung bình**, số lượng item không quá lớn, và bạn muốn cuộn dọc với `Column`.

### Cách làm

```kotlin
@Composable
fun ScrollingColumn() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(12.dp)
    ) {
        Image(
            painter = painterResource(R.drawable.pic1),
            contentDescription = "Picture 1",
            contentScale = ContentScale.FillWidth,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(Modifier.height(8.dp))

        Image(
            painter = painterResource(R.drawable.pic2),
            contentDescription = "Picture 2",
            contentScale = ContentScale.FillWidth,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(Modifier.height(8.dp))

        Image(
            painter = painterResource(R.drawable.pic3),
            contentDescription = "Picture 3",
            contentScale = ContentScale.FillWidth,
            modifier = Modifier.fillMaxWidth()
        )
    }
}
```

### Ghi nhớ

- `verticalScroll(...)` render **toàn bộ item một lần**.
- Nếu danh sách dài, nên chuyển sang `LazyColumn`.

---

## 4) Scrolling Row

### Khi nào dùng?

Dùng khi muốn cuộn ngang một nhóm item nhỏ (banner, gallery, category chips).

### Lưu ý quan trọng từ project

```kotlin
@Composable
fun ScrollingRow() {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .horizontalScroll(rememberScrollState())
            .padding(12.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Image(
            painter = painterResource(R.drawable.pic1),
            contentDescription = "Picture 1",
            contentScale = ContentScale.Crop,
            modifier = Modifier.size(width = 180.dp, height = 120.dp)
        )
        Image(
            painter = painterResource(R.drawable.pic2),
            contentDescription = "Picture 2",
            contentScale = ContentScale.Crop,
            modifier = Modifier.size(width = 180.dp, height = 120.dp)
        )
        Image(
            painter = painterResource(R.drawable.pic3),
            contentDescription = "Picture 3",
            contentScale = ContentScale.Crop,
            modifier = Modifier.size(width = 180.dp, height = 120.dp)
        )
    }
}
```
### Ghi nhớ

- `horizontalScroll(...)` render toàn bộ item một lần.
- Nếu danh sách dài, nên chuyển sang `LazyRow`.
---

## 5) Lazy Column

### Vì sao cần `LazyColumn`?

`LazyColumn` chỉ render các item đang hiển thị trên màn hình (và một phần buffer), giúp:

- Tiết kiệm RAM
- Mượt hơn khi danh sách dài
- Dễ quản lý item động

### Ví dụ cơ bản

```kotlin
@Composable
fun MyLazyColumn() {
    val itemsList = List(100) { index -> "Item ${index + 1}" }

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(12.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(
            items = itemsList,
            key = { it } // key ổn định giúp tối ưu recompose
        ) { item ->
            Text(
                text = item,
                modifier = Modifier
                    .fillMaxWidth()
                    .background(Color(0xFFE8F5E9))
                    .padding(16.dp)
            )
        }
    }
}
```

### Khi nào chọn `Column` vs `LazyColumn`?

- `Column + verticalScroll`: danh sách ít, UI đơn giản
- `LazyColumn`: danh sách dài, dữ liệu lớn, list động từ API/DB

---

## 6) Custom List Layout

Mục tiêu: một danh sách có **nhiều loại item** (header, nội dung, quảng cáo, nhóm dữ liệu, ...).

### Bước 1: Tạo model nhiều kiểu

```kotlin
sealed interface FeedItem {
    data class Header(val title: String) : FeedItem
    data class Article(val id: String, val title: String, val summary: String) : FeedItem
    data class Banner(val text: String) : FeedItem
}
```

### Bước 2: Render theo loại item

```kotlin
@Composable
fun CustomListLayout(feedItems: List<FeedItem>) {
    LazyColumn(
        contentPadding = PaddingValues(12.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(
            items = feedItems,
            key = {
                when (it) {
                    is FeedItem.Header -> "header-${it.title}"
                    is FeedItem.Article -> "article-${it.id}"
                    is FeedItem.Banner -> "banner-${it.text}"
                }
            }
        ) { item ->
            when (item) {
                is FeedItem.Header -> {
                    Text(
                        text = item.title,
                        style = MaterialTheme.typography.titleLarge
                    )
                }
                is FeedItem.Article -> {
                    Card(modifier = Modifier.fillMaxWidth()) {
                        Column(Modifier.padding(16.dp)) {
                            Text(item.title, style = MaterialTheme.typography.titleMedium)
                            Spacer(Modifier.height(6.dp))
                            Text(item.summary, style = MaterialTheme.typography.bodyMedium)
                        }
                    }
                }
                is FeedItem.Banner -> {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .background(Color(0xFFFFF8E1))
                            .padding(16.dp)
                    ) {
                        Text(item.text)
                    }
                }
            }
        }
    }
}
```

### Ý nghĩa

- Dễ mở rộng loại item
- Dễ test UI
- Bám sát bài toán thực tế app tin tức, thương mại điện tử, mạng xã hội

---

## 7) Lazy Row

### Khi nào dùng?

Danh sách ngang dài và có thể cuộn hiệu quả (VD: danh mục, sản phẩm gợi ý, ảnh thumbnail).

```kotlin
@Composable
fun MyLazyRow() {
    val itemList = List(30) { index -> "Item ${index + 1}" }

    LazyRow(
        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(itemList, key = { it }) { item ->
            Card {
                Text(
                    text = item,
                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 10.dp)
                )
            }
        }
    }
}
```

---

## 8) Sticky Headers

`stickyHeader` giúp phần tiêu đề nhóm luôn dính ở đầu khi cuộn.

> Cần opt-in `ExperimentalFoundationApi`.

```kotlin
@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ContactListWithStickyHeader() {
    val grouped = mapOf(
        "A" to listOf("An", "Anh"),
        "B" to listOf("Binh", "Bao"),
        "C" to listOf("Cuong")
    )

    LazyColumn {
        grouped.forEach { (group, names) ->
            stickyHeader {
                Text(
                    text = group,
                    modifier = Modifier
                        .fillMaxWidth()
                        .background(Color.LightGray)
                        .padding(8.dp),
                    style = MaterialTheme.typography.titleMedium
                )
            }

            items(names, key = { it }) { name ->
                Text(
                    text = name,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 12.dp, vertical = 10.dp)
                )
            }
        }
    }
}
```

---

## 9) Handling Click Events on Items List

Trong project hiện tại đang dùng `pointerInput + detectTapGestures`. Đây là cách linh hoạt khi cần nhiều cử chỉ.

### Cách 1: Đơn giản với `clickable`

```kotlin
@Composable
fun ClickableItem(
    title: String,
    onClick: (String) -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick(title) }
            .padding(16.dp)
    ) {
        Text(title)
    }
}
```

### Cách 2: Click + Long Click với `combinedClickable`

```kotlin
@OptIn(ExperimentalFoundationApi::class)
@Composable
fun GestureItem(
    title: String,
    onClick: (String) -> Unit,
    onLongClick: (String) -> Unit
) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .combinedClickable(
                onClick = { onClick(title) },
                onLongClick = { onLongClick(title) }
            )
            .padding(16.dp)
    ) {
        Text(text = title)
    }
}
```

### Khi nào dùng `pointerInput`?

- Cần gesture tùy biến sâu (double-tap, drag riêng, nhiều trạng thái chạm)
- Còn bài toán click cơ bản thì ưu tiên `clickable`/`combinedClickable` để code gọn và dễ bảo trì

---

## 10) Cards trong List

`Card` giúp item rõ ràng hơn về thị giác và phân tách nội dung tốt.

```kotlin
@Composable
fun MyCardItem(
    title: String,
    subtitle: String
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color(0xFFFFFDE7)
        )
    ) {
        Column(Modifier.padding(16.dp)) {
            Text(text = title, style = MaterialTheme.typography.titleMedium)
            Spacer(Modifier.height(4.dp))
            Text(text = subtitle, style = MaterialTheme.typography.bodyMedium)
        }
    }
}
```

Kết hợp `Card` + `LazyColumn`:

```kotlin
@Composable
fun CardListScreen() {
    val data = List(20) { index -> "Mục ${index + 1}" }

    LazyColumn(
        contentPadding = PaddingValues(12.dp),
        verticalArrangement = Arrangement.spacedBy(10.dp)
    ) {
        items(data, key = { it }) { item ->
            MyCardItem(
                title = item,
                subtitle = "Mô tả ngắn cho $item"
            )
        }
    }
}
```

---

## 11) Checklist thực hành cho người mới

1. Bắt đầu với `Column/Row + scroll` để hiểu cơ chế cuộn.
2. Chuyển sang `LazyColumn/LazyRow` khi danh sách có thể dài.
3. Luôn thêm `key` ổn định nếu item có id.
4. Tách `ItemComposable` riêng để dễ tái sử dụng.
5. Ưu tiên `clickable/combinedClickable`; chỉ dùng `pointerInput` khi cần gesture nâng cao.
6. Dùng `Card` để cải thiện UX và khả năng đọc.
7. Dùng `stickyHeader` cho danh sách có nhóm dữ liệu.

---

## 12) Tổng kết

Với project `JetpackList`, bạn đã có nền tảng tốt để học List trong Compose.  
Lộ trình phù hợp cho người mới:

- Bước 1: `ScrollingColumn`, `ScrollingRow`
- Bước 2: `LazyColumn`, `LazyRow`
- Bước 3: `Custom List Layout`, `Sticky Headers`
- Bước 4: xử lý click/long-click và thiết kế item bằng `Card`

Nếu cần, có thể nâng cấp tiếp sang:

- `animateItemPlacement()` cho hiệu ứng khi đổi vị trí item
- Paging 3 cho dữ liệu lớn từ API
- Pull-to-refresh cho danh sách cập nhật liên tục
