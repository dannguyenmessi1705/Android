# Android Components: Services, Broadcast Receiver, Intent Filters

Tài liệu này hướng dẫn chi tiết cho người mới bắt đầu về **Services**, **Broadcast Receivers** và **Intent Filters** trong Android. Mục tiêu là hiểu được khái niệm, vòng đời, cách sử dụng, và các tình huống thực tế thường gặp.

---

## 1) What are Components (Các thành phần của ứng dụng)

Trong Android, một ứng dụng được tạo nên từ **4 thành phần chính** (App Components):

| Component | Mô tả ngắn |
|----------|-----------|
| **Activity** | Màn hình UI, nơi người dùng tương tác trực tiếp |
| **Service** | Chạy tác vụ nền, không có UI |
| **BroadcastReceiver** | Nhận các sự kiện (broadcast) từ hệ thống hoặc app khác |
| **ContentProvider** | Chia sẻ dữ liệu giữa các ứng dụng |

**Đặc điểm chung:**
- Mỗi component có vòng đời (lifecycle) riêng.
- Các component giao tiếp với nhau qua **Intent**.
- Tất cả component phải khai báo trong `AndroidManifest.xml`.

**Ví dụ đơn giản về luồng hoạt động:**
1. Activity gọi `startService()` để tải dữ liệu nền.
2. Service tải dữ liệu và gửi broadcast thông báo hoàn tất.
3. BroadcastReceiver nhận broadcast và cập nhật UI.

---

## 2) Services & Their Life Cycle

### 2.1 Service là gì?
**Service** là một component chạy nền, **không có giao diện**, dùng cho các tác vụ dài hoặc cần chạy ngay cả khi người dùng không ở trong app.

**Ví dụ thực tế:**
- Phát nhạc khi người dùng tắt màn hình.
- Tải dữ liệu nền.
- Theo dõi vị trí (location tracking).

### 2.2 Các loại Service

| Loại Service | Mô tả | Cách khởi tạo |
|------------|------|-------------|
| **Started Service** | Chạy đến khi tự dừng hoặc bị stop | `startService()` |
| **Bound Service** | Chạy khi có component bind vào | `bindService()` |
| **Foreground Service** | Service hiển thị notification bắt buộc | `startForegroundService()` |

**Lưu ý quan trọng (Android 8.0+):**  
Hệ thống hạn chế chạy background service. Nếu cần chạy lâu, hãy dùng **Foreground Service** hoặc **WorkManager**.

### 2.3 Vòng đời của Service

#### A) Started Service (startService)
```
onCreate() → onStartCommand() → (Service chạy) → onDestroy()
```

#### B) Bound Service (bindService)
```
onCreate() → onBind() → (Service chạy khi có kết nối) → onUnbind() → onDestroy()
```

### 2.4 Các callback quan trọng

| Method | Khi nào được gọi | Mục đích |
|--------|------------------|---------|
| `onCreate()` | Lần đầu service được tạo | Khởi tạo tài nguyên |
| `onStartCommand()` | Mỗi lần gọi `startService()` | Bắt đầu xử lý tác vụ |
| `onBind()` | Khi component bind vào | Trả về IBinder |
| `onUnbind()` | Khi không còn component bind | Dọn dẹp nhẹ |
| `onDestroy()` | Khi service bị dừng | Giải phóng tài nguyên |

---

## 3) Services App (Ví dụ ứng dụng Service)

Dưới đây là ví dụ **Started Service** đơn giản: service chạy 10 giây và log mỗi giây.

### 3.1 Tạo Service

```kotlin
// File: TimerService.kt
package com.example.myapp.service

import android.app.Service
import android.content.Intent
import android.os.IBinder
import android.util.Log
import kotlinx.coroutines.*

class TimerService : Service() {

    private val serviceJob = SupervisorJob()
    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)

    override fun onCreate() {
        super.onCreate()
        Log.d("TimerService", "onCreate")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d("TimerService", "onStartCommand")

        serviceScope.launch {
            repeat(10) { i ->
                Log.d("TimerService", "Tick: $i")
                delay(1000)
            }
            stopSelf() // Tự dừng sau khi hoàn tất
        }

        return START_NOT_STICKY
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null // Started Service không cần bind
    }

    override fun onDestroy() {
        super.onDestroy()
        serviceJob.cancel()
        Log.d("TimerService", "onDestroy")
    }
}
```

### 3.2 Khai báo trong Manifest

```xml
<service
    android:name=".service.TimerService"
    android:exported="false" />
```

### 3.3 Gọi Service từ Activity

```kotlin
// File: MainActivity.kt
val startIntent = Intent(this, TimerService::class.java)
startService(startIntent)

// Dừng Service
val stopIntent = Intent(this, TimerService::class.java)
stopService(stopIntent)
```

---

## 4) onStartCommand() Method

`onStartCommand()` là nơi Service nhận lệnh khi `startService()` được gọi.

### 4.1 Cú pháp

```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    // Xử lý công việc ở đây
    return START_NOT_STICKY
}
```

### 4.2 Các tham số

| Tham số | Ý nghĩa |
|--------|--------|
| `intent` | Intent được dùng để startService (có thể null) |
| `flags` | Cờ hệ thống (thường ít dùng) |
| `startId` | ID riêng cho mỗi lần startService |

### 4.3 Giá trị trả về (quan trọng)

| Giá trị | Ý nghĩa |
|--------|--------|
| `START_NOT_STICKY` | Nếu bị kill, **không restart** |
| `START_STICKY` | Nếu bị kill, **tự restart**, intent = null |
| `START_REDELIVER_INTENT` | Restart và **gửi lại Intent cũ** |

**Gợi ý lựa chọn:**
- Tác vụ ngắn, không cần restart: `START_NOT_STICKY`.
- Tác vụ dài cần chạy liên tục: `START_STICKY`.
- Cần xử lý lại dữ liệu nếu bị kill: `START_REDELIVER_INTENT`.

---

## 5) Starting & Stopping Services

### 5.1 Start Service

```kotlin
val intent = Intent(this, TimerService::class.java)
startService(intent)
```

### 5.2 Stop Service

```kotlin
val intent = Intent(this, TimerService::class.java)
stopService(intent)
```

### 5.3 Stop chính service

```kotlin
stopSelf() // Dừng service từ bên trong
```

### 5.4 Foreground Service (chạy lâu, cần thông báo)

Android 8.0+ yêu cầu **foreground service** nếu chạy lâu ở nền.

```kotlin
// Activity: bắt đầu foreground service
val intent = Intent(this, MusicService::class.java)
startForegroundService(intent)
```

Trong Service phải gọi `startForeground()` trong vòng vài giây:

```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    startForeground(NOTI_ID, buildNotification())
    return START_STICKY
}
```

**Manifest cần quyền:**
```xml
<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
```

### 5.5 Foreground Service chi tiết với Notification Channel

Android 8.0 (API 26) trở lên yêu cầu **Notification Channel** cho mọi notification.  
Foreground Service bắt buộc phải hiển thị notification liên tục.

#### Bước 1: Khai báo Service trong Manifest

```xml
<service
    android:name=".service.MusicService"
    android:exported="false"
    android:foregroundServiceType="mediaPlayback" />
```

**Gợi ý foregroundServiceType thường gặp:**
- `mediaPlayback` (phát nhạc)
- `location` (theo dõi vị trí)
- `dataSync` (đồng bộ dữ liệu)

#### Bước 2: Tạo Notification Channel

```kotlin
private const val CHANNEL_ID = "music_channel"
private const val CHANNEL_NAME = "Music Playback"

private fun createNotificationChannel() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(
            CHANNEL_ID,
            CHANNEL_NAME,
            NotificationManager.IMPORTANCE_LOW
        ).apply {
            description = "Notifications for music playback"
        }

        val manager = getSystemService(Context.NOTIFICATION_SERVICE)
                as NotificationManager
        manager.createNotificationChannel(channel)
    }
}
```

#### Bước 3: Build Notification

```kotlin
private fun buildNotification(): Notification {
    val intent = Intent(this, MainActivity::class.java)
    val pendingIntent = PendingIntent.getActivity(
        this,
        0,
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )

    return NotificationCompat.Builder(this, CHANNEL_ID)
        .setContentTitle("Đang phát nhạc")
        .setContentText("Bài hát đang chạy ở nền")
        .setSmallIcon(R.drawable.ic_music_note)
        .setContentIntent(pendingIntent)
        .setOngoing(true) // Không cho vuốt tắt
        .build()
}
```

#### Bước 4: Service đầy đủ (Foreground Service)

```kotlin
// File: MusicService.kt
class MusicService : Service() {

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = buildNotification()
        startForeground(1, notification)

        // Bắt đầu phát nhạc hoặc tác vụ dài
        startPlayback()

        return START_STICKY
    }

    override fun onDestroy() {
        super.onDestroy()
        stopPlayback()
        stopForeground(STOP_FOREGROUND_REMOVE)
    }

    override fun onBind(intent: Intent?): IBinder? = null
}
```

#### Bước 5: Start/Stop từ Activity

```kotlin
// Start
val intent = Intent(this, MusicService::class.java)
startForegroundService(intent)

// Stop
stopService(intent)
```

**Lưu ý quan trọng:**
- Với Android 12+, nếu chạy foreground service cho location/camera/mic cần quyền phù hợp.
- Notification phải hiển thị ngay sau khi service bắt đầu (thường trong vài giây).

### 5.6 Foreground Service với Notification Action (Play/Pause)

Mục tiêu: thêm nút **Play/Pause** ngay trong notification để điều khiển service.

#### Bước 1: Định nghĩa action và xử lý trong Service

```kotlin
companion object {
    const val ACTION_PLAY = "com.example.myapp.action.PLAY"
    const val ACTION_PAUSE = "com.example.myapp.action.PAUSE"
}

override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    when (intent?.action) {
        ACTION_PLAY -> startPlayback()
        ACTION_PAUSE -> pausePlayback()
        else -> {
            val notification = buildNotification(isPlaying = true)
            startForeground(1, notification)
            startPlayback()
        }
    }
    return START_STICKY
}
```

#### Bước 2: Tạo PendingIntent cho action

```kotlin
private fun createActionIntent(action: String): PendingIntent {
    val intent = Intent(this, MusicService::class.java).apply {
        this.action = action
    }
    return PendingIntent.getService(
        this,
        action.hashCode(),
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
}
```

#### Bước 3: Build notification có nút Play/Pause

```kotlin
private fun buildNotification(isPlaying: Boolean): Notification {
    val openAppIntent = Intent(this, MainActivity::class.java)
    val contentIntent = PendingIntent.getActivity(
        this,
        0,
        openAppIntent,
        PendingIntent.FLAG_IMMUTABLE
    )

    val playIntent = createActionIntent(ACTION_PLAY)
    val pauseIntent = createActionIntent(ACTION_PAUSE)

    val playAction = NotificationCompat.Action(
        R.drawable.ic_play,
        "Play",
        playIntent
    )
    val pauseAction = NotificationCompat.Action(
        R.drawable.ic_pause,
        "Pause",
        pauseIntent
    )

    return NotificationCompat.Builder(this, CHANNEL_ID)
        .setContentTitle("Music Player")
        .setContentText(if (isPlaying) "Đang phát" else "Đang tạm dừng")
        .setSmallIcon(R.drawable.ic_music_note)
        .setContentIntent(contentIntent)
        .setOngoing(true)
        .addAction(if (isPlaying) pauseAction else playAction)
        .build()
}
```

#### Bước 4: Cập nhật notification khi trạng thái đổi

```kotlin
private fun updateNotification(isPlaying: Boolean) {
    val manager = NotificationManagerCompat.from(this)
    val notification = buildNotification(isPlaying)
    manager.notify(1, notification)
}
```

**Lưu ý:**
- Nếu cần hiển thị notification trên Android 13+, hãy xin quyền `POST_NOTIFICATIONS`.
- Khi trạng thái phát/dừng thay đổi, hãy gọi `updateNotification(...)` để cập nhật action.

### 5.7 Xử lý Notification Action bằng BroadcastReceiver

Thay vì gửi action trực tiếp vào Service bằng `PendingIntent.getService()`, bạn có thể dùng **BroadcastReceiver** để nhận sự kiện, sau đó điều khiển Service.

#### Bước 1: Tạo BroadcastReceiver

```kotlin
// File: MusicActionReceiver.kt
class MusicActionReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val action = intent.action
        val serviceIntent = Intent(context, MusicService::class.java).apply {
            this.action = action
        }
        context.startService(serviceIntent)
    }
}
```

#### Bước 2: Khai báo Receiver trong Manifest

```xml
<receiver
    android:name=".receiver.MusicActionReceiver"
    android:exported="false" />
```

#### Bước 3: Tạo PendingIntent gửi broadcast

```kotlin
private fun createBroadcastAction(action: String): PendingIntent {
    val intent = Intent(this, MusicActionReceiver::class.java).apply {
        this.action = action
    }
    return PendingIntent.getBroadcast(
        this,
        action.hashCode(),
        intent,
        PendingIntent.FLAG_IMMUTABLE
    )
}
```

#### Bước 4: Gắn action vào notification

```kotlin
val playIntent = createBroadcastAction(ACTION_PLAY)
val pauseIntent = createBroadcastAction(ACTION_PAUSE)

val playAction = NotificationCompat.Action(
    R.drawable.ic_play,
    "Play",
    playIntent
)
val pauseAction = NotificationCompat.Action(
    R.drawable.ic_pause,
    "Pause",
    pauseIntent
)
```

**Ưu điểm của cách này:**
- Dễ tái sử dụng cho nhiều component khác nhau.
- Giúp tách riêng phần xử lý action khỏi Service.

### 5.8 MediaSession + MediaStyle (chuẩn cho app phát nhạc)

**MediaSession** giúp Android hiểu trạng thái phát nhạc, hiển thị tốt trên lock screen, tai nghe, Android Auto.

#### Bước 1: Thêm dependency

```gradle
implementation("androidx.media:media:1.7.0")
```

#### Bước 2: Tạo MediaSession trong Service

```kotlin
private lateinit var mediaSession: MediaSessionCompat

override fun onCreate() {
    super.onCreate()
    createNotificationChannel()

    mediaSession = MediaSessionCompat(this, "MusicService").apply {
        isActive = true
    }
}
```

#### Bước 3: Build MediaStyle notification

```kotlin
private fun buildMediaNotification(isPlaying: Boolean): Notification {
    val playIntent = createBroadcastAction(ACTION_PLAY)
    val pauseIntent = createBroadcastAction(ACTION_PAUSE)

    val playAction = NotificationCompat.Action(
        R.drawable.ic_play,
        "Play",
        playIntent
    )
    val pauseAction = NotificationCompat.Action(
        R.drawable.ic_pause,
        "Pause",
        pauseIntent
    )

    return NotificationCompat.Builder(this, CHANNEL_ID)
        .setContentTitle("Now Playing")
        .setContentText("Best track")
        .setSmallIcon(R.drawable.ic_music_note)
        .setStyle(
            androidx.media.app.NotificationCompat.MediaStyle()
                .setMediaSession(mediaSession.sessionToken)
                .setShowActionsInCompactView(0)
        )
        .addAction(if (isPlaying) pauseAction else playAction)
        .setOngoing(true)
        .build()
}
```

#### Bước 4: Cập nhật trạng thái phát nhạc

```kotlin
private fun updatePlaybackState(isPlaying: Boolean) {
    val state = if (isPlaying) {
        PlaybackStateCompat.STATE_PLAYING
    } else {
        PlaybackStateCompat.STATE_PAUSED
    }
    val playbackState = PlaybackStateCompat.Builder()
        .setState(state, PlaybackStateCompat.PLAYBACK_POSITION_UNKNOWN, 1.0f)
        .setActions(
            PlaybackStateCompat.ACTION_PLAY or
            PlaybackStateCompat.ACTION_PAUSE
        )
        .build()

    mediaSession.setPlaybackState(playbackState)
}
```

**Gợi ý:** Khi stop service, nhớ `mediaSession.release()` để giải phóng tài nguyên.

### 5.9 MediaSession với MediaButtonReceiver (tai nghe/lock screen)

Mục tiêu: nhận sự kiện nút tai nghe (play/pause/next) từ hệ thống.

#### Bước 1: Thêm dependency

```gradle
implementation("androidx.media:media:1.7.0")
```

#### Bước 2: Khai báo MediaButtonReceiver trong Manifest

```xml
<receiver
    android:name="androidx.media.session.MediaButtonReceiver"
    android:exported="false">
    <intent-filter>
        <action android:name="android.intent.action.MEDIA_BUTTON" />
    </intent-filter>
</receiver>
```

#### Bước 3: Tạo MediaSession và gắn callback

```kotlin
private lateinit var mediaSession: MediaSessionCompat

override fun onCreate() {
    super.onCreate()
    createNotificationChannel()

    mediaSession = MediaSessionCompat(this, "MusicService").apply {
        setCallback(object : MediaSessionCompat.Callback() {
            override fun onPlay() {
                startPlayback()
                updateNotification(isPlaying = true)
            }

            override fun onPause() {
                pausePlayback()
                updateNotification(isPlaying = false)
            }

            override fun onSkipToNext() {
                playNext()
                updateNotification(isPlaying = true)
            }
        })
        isActive = true
    }
}
```

#### Bước 4: Gắn MediaButtonReceiver vào notification

```kotlin
private fun buildMediaNotification(isPlaying: Boolean): Notification {
    val mediaButtonIntent = MediaButtonReceiver.buildMediaButtonPendingIntent(
        this,
        if (isPlaying) PlaybackStateCompat.ACTION_PAUSE else PlaybackStateCompat.ACTION_PLAY
    )

    return NotificationCompat.Builder(this, CHANNEL_ID)
        .setContentTitle("Now Playing")
        .setContentText("Best track")
        .setSmallIcon(R.drawable.ic_music_note)
        .setStyle(
            androidx.media.app.NotificationCompat.MediaStyle()
                .setMediaSession(mediaSession.sessionToken)
                .setShowActionsInCompactView(0)
        )
        .addAction(
            NotificationCompat.Action(
                if (isPlaying) R.drawable.ic_pause else R.drawable.ic_play,
                if (isPlaying) "Pause" else "Play",
                mediaButtonIntent
            )
        )
        .setOngoing(true)
        .build()
}
```

**Lưu ý:**
- Hệ thống tự xử lý sự kiện nút tai nghe và gọi `MediaSession.Callback`.
- Nếu muốn xử lý nhiều action (next/prev), hãy thêm vào `PlaybackStateCompat.Builder().setActions(...)`.

---

## 6) Broadcast Receivers

### 6.1 Broadcast Receiver là gì?
**BroadcastReceiver** là component dùng để lắng nghe các sự kiện (broadcast), ví dụ:
- Khi thiết bị vừa khởi động xong.
- Khi pin yếu.
- Khi có kết nối mạng thay đổi.

### 6.2 Hai cách đăng ký Receiver

| Loại | Đăng ký ở đâu | Khi nào hoạt động |
|------|---------------|------------------|
| **Static (Manifest)** | `AndroidManifest.xml` | Hoạt động cả khi app chưa chạy |
| **Dynamic (Runtime)** | Code (Activity/Service) | Chỉ hoạt động khi app đang chạy |

### 6.3 Ví dụ Static Receiver

```kotlin
// File: BootReceiver.kt
class BootReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            Log.d("BootReceiver", "Device rebooted")
        }
    }
}
```

Manifest:
```xml
<receiver
    android:name=".receiver.BootReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
    </intent-filter>
</receiver>
```

**Lưu ý:** Cần thêm permission:
```xml
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
```

### 6.4 Ví dụ Dynamic Receiver

```kotlin
private val batteryReceiver = object : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
        Log.d("BatteryReceiver", "Battery level: $level")
    }
}

override fun onStart() {
    super.onStart()
    registerReceiver(batteryReceiver, IntentFilter(Intent.ACTION_BATTERY_CHANGED))
}

override fun onStop() {
    super.onStop()
    unregisterReceiver(batteryReceiver)
}
```

---

## 7) Intent Filters

### 7.1 Intent Filter là gì?
**Intent Filter** mô tả loại Intent mà component có thể xử lý.  
Nó gồm 3 phần: **Action**, **Category**, **Data**.

### 7.2 Cấu trúc cơ bản

```xml
<intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <data android:mimeType="image/*" />
</intent-filter>
```

### 7.3 Ví dụ Intent Filter cho Activity

```xml
<activity
    android:name=".ui.ImageViewerActivity"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <data android:mimeType="image/*" />
    </intent-filter>
</activity>
```

### 7.4 Ví dụ Intent Filter cho BroadcastReceiver

```xml
<receiver
    android:name=".receiver.NetworkReceiver"
    android:exported="false">
    <intent-filter>
        <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
    </intent-filter>
</receiver>
```

### 7.5 Intent Filter với custom action

```xml
<receiver
    android:name=".receiver.CustomReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="com.example.myapp.MY_ACTION" />
    </intent-filter>
</receiver>
```

Gửi broadcast:
```kotlin
val intent = Intent("com.example.myapp.MY_ACTION")
sendBroadcast(intent)
```

### 7.6 Intent Filter trong code (Dynamic)

```kotlin
val filter = IntentFilter().apply {
    addAction(Intent.ACTION_POWER_CONNECTED)
    addAction(Intent.ACTION_POWER_DISCONNECTED)
}
registerReceiver(powerReceiver, filter)
```

---

## 8) Tóm tắt nhanh

| Chủ đề | Ý chính |
|-------|---------|
| **Service** | Chạy tác vụ nền, có started/bound/foreground |
| **onStartCommand()** | Nơi xử lý logic khi startService |
| **BroadcastReceiver** | Nhận sự kiện hệ thống/app |
| **IntentFilter** | Khai báo loại Intent mà component xử lý |

---

## 9) Gợi ý thực hành cho người mới

1. Tạo một **Started Service** chạy 5 giây và tự dừng.
2. Tạo một **BroadcastReceiver** nhận ACTION_POWER_CONNECTED.
3. Thử gửi một broadcast custom từ Activity.
4. Thử viết một Intent Filter để mở Activity khi chia sẻ text.
