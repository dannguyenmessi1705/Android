# 17. Retrofit Android

Tài liệu này hướng dẫn Retrofit cho người mới bắt đầu dựa trên chính project hiện tại trong repo này (module `app`). Bạn có thể đối chiếu trực tiếp các ví dụ trong:

- `app/build.gradle.kts`
- `app/src/main/AndroidManifest.xml`
- `app/src/main/java/com/didan/android/retrofit/AlbumItem.kt`
- `app/src/main/java/com/didan/android/retrofit/Albums.kt`
- `app/src/main/java/com/didan/android/retrofit/AlbumService.kt`
- `app/src/main/java/com/didan/android/retrofit/RetrofitInstance.kt`
- `app/src/main/java/com/didan/android/retrofit/MainActivity.kt`

---

## Mục lục

1. [Retrofit Intro](#1-retrofit-intro)
2. [Retrofit Dependency](#2-retrofit-dependency)
3. [Adding Permissions](#3-adding-permissions)
4. [JSON Syntax](#4-json-syntax)
5. [POJO Data Class](#5-pojo-data-class)
6. [JSON Array](#6-json-array)
7. [API Service Interface](#7-api-service-interface)
8. [Retrofit Instance](#8-retrofit-instance)
9. [Implementing Retrofit](#9-implementing-retrofit)
10. [HTTP Requests & Responses](#10-http-requests--responses)
11. [Query Parameters](#11-query-parameters)
12. [Path Parameters](#12-path-parameters)
13. [Receiving JSON to Logcat](#13-receiving-json-to-logcat)
14. [Displaying JSON into TextView](#14-displaying-json-into-textview)
15. [Network Security Rules](#15-network-security-rules)

---

## 1. Retrofit Intro

**Retrofit** là một thư viện HTTP client dành cho Android (Square) giúp bạn gọi API REST đơn giản hơn bằng cách:

- Khai báo API bằng **interface** + **annotation** (`@GET`, `@POST`, `@Query`, `@Path`, …).
- Tự động chuyển đổi JSON ⇄ object Kotlin/Java thông qua **Converter** (Gson/Moshi/…).
- Kết hợp tốt với **Coroutines** (`suspend`) để viết bất đồng bộ gọn và rõ.

Trong project này, API ví dụ dùng `https://jsonplaceholder.typicode.com` (fake REST API).

---

## 2. Retrofit Dependency

### 2.1. Dependencies trong project hiện tại

Project đang dùng **Version Catalog** (`gradle/libs.versions.toml`) và khai báo ở `app/build.gradle.kts`:

```kts
// Retrofit
implementation(libs.retrofit)
// Converter Gson
implementation(libs.retrofit.converter.gson)
// Gson
implementation(libs.gson)

// Coroutine (bất đồng bộ)
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.10.2")

// OkHttp Logging Interceptor (log request/response)
implementation("com.squareup.okhttp3:logging-interceptor:5.3.0")
```

> Gợi ý: nếu bạn không dùng Version Catalog, bạn có thể khai báo trực tiếp bằng chuỗi dependency trong `app/build.gradle(.kts)`.

### 2.2. Sync Gradle

Sau khi thêm dependency, bấm **Sync Now** (Android Studio) để Gradle tải thư viện.

---

## 3. Adding Permissions

Để gọi mạng, Android cần quyền **INTERNET** trong `AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

Trong project này, bạn đã có sẵn:

- `android.permission.INTERNET`
- `android.permission.ACCESS_NETWORK_STATE`
- `android.permission.ACCESS_WIFI_STATE`

> Lưu ý: `ACCESS_NETWORK_STATE`/`ACCESS_WIFI_STATE` không bắt buộc để gọi Retrofit, nhưng hữu ích nếu bạn muốn kiểm tra trạng thái mạng.

---

## 4. JSON Syntax

Retrofit thường làm việc với dữ liệu JSON từ server.

### 4.1. JSON Object (đối tượng)

Ví dụ 1 album dạng object:

```json
{
  "userId": 1,
  "id": 1,
  "title": "quidem molestiae enim"
}
```

- **Key** luôn là chuỗi (có dấu ngoặc kép).
- **Value** có thể là number, string, boolean, null, object, array.

### 4.2. JSON Array (mảng)

Ví dụ danh sách album dạng array:

```json
[
  { "userId": 1, "id": 1, "title": "..." },
  { "userId": 1, "id": 2, "title": "..." }
]
```

---

## 5. POJO Data Class

“POJO” (Plain Old Java Object) là cách gọi chung cho class chỉ chứa dữ liệu. Với Kotlin, ta thường dùng **data class**.

### 5.1. Model `AlbumItem`

Trong project, bạn có:

```kotlin
data class AlbumItem(
    @SerializedName("userId") val userId: Int,
    @SerializedName("id") val id: Int,
    @SerializedName("title") val title: String
)
```

Giải thích:

- `@SerializedName("userId")` dùng khi tên field JSON và tên thuộc tính Kotlin **khác nhau** hoặc để “chắc ăn”.
- Nếu JSON key trùng tên thuộc tính, bạn có thể bỏ `@SerializedName` (Gson vẫn map được).

### 5.2. Nullable & default value (khuyến nghị)

API thực tế có thể trả thiếu field hoặc null. Để app ít crash hơn:

```kotlin
data class AlbumItem(
    @SerializedName("userId") val userId: Int? = null,
    @SerializedName("id") val id: Int? = null,
    @SerializedName("title") val title: String? = null
)
```

---

## 6. JSON Array

Khi API trả về **mảng JSON**, Retrofit có thể map trực tiếp sang:

- `List<AlbumItem>`
- hoặc một type kế thừa `ArrayList<AlbumItem>` (như project này)

Project đang dùng:

```kotlin
class Albums : ArrayList<AlbumItem>()
```

Điều này giúp type trả về gọn: `Response<Albums>` thay vì `Response<List<AlbumItem>>`.

---

## 7. API Service Interface

Retrofit yêu cầu bạn khai báo các endpoint trong một **interface**. Project có `AlbumService`:

```kotlin
interface AlbumService {
    @GET("/albums")
    suspend fun getAlbums(): Response<Albums>

    @GET("/albums")
    suspend fun getSpecificAlbums(@Query("userId") userId: Int): Response<Albums>
}
```

Giải thích nhanh:

- `@GET` là HTTP GET.
- `suspend` để gọi trong coroutine (không block UI).
- `Response<Albums>` chứa cả **status code, headers, body, errorBody**.
- `@Query("userId")` tạo URL dạng `.../albums?userId=6`.

> Khuyến nghị: thường viết `@GET("albums")` (không có dấu `/`) để tránh nhầm lẫn khi ghép với `baseUrl`.

---

## 8. Retrofit Instance

Bạn cần một nơi cấu hình Retrofit (baseUrl + converter + (tuỳ chọn) OkHttpClient).

### 8.1. Cấu hình cơ bản (như project)

```kotlin
Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(
        GsonConverterFactory.create(GsonBuilder().create())
    )
    .build()
```

> Lưu ý quan trọng: `baseUrl` của Retrofit **thường phải kết thúc bằng dấu `/`** (ví dụ: `https://jsonplaceholder.typicode.com/`). Nếu thiếu `/`, Retrofit có thể báo lỗi khi build.

### 8.2. Nâng cao: bật log request/response bằng OkHttp Logging Interceptor

<a id="retrofit-log-interceptor"></a>

Project đã có dependency `logging-interceptor`, bạn có thể gắn vào Retrofit như sau:

```kotlin
val interceptor = HttpLoggingInterceptor().apply {
    level = HttpLoggingInterceptor.Level.BODY
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(interceptor)
    .build()

val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .client(okHttpClient)
    .addConverterFactory(GsonConverterFactory.create())
    .build()
```

Khi bật, Logcat sẽ hiển thị URL, headers và body (hữu ích lúc debug).

---

## 9. Implementing Retrofit

Một luồng triển khai Retrofit “chuẩn” cho người mới:

1. **Chuẩn bị API** (base URL + endpoint).
2. **Tạo model** (POJO/data class) map JSON.
3. **Tạo service interface** chứa endpoint.
4. **Tạo Retrofit instance** (singleton).
5. **Gọi API** từ UI layer (Activity/Fragment) hoặc tốt hơn là từ ViewModel/Repository.
6. **Hiển thị dữ liệu** lên UI.

Trong project hiện tại:

- Model: `AlbumItem`, `Albums`
- Service: `AlbumService`
- Instance: `RetrofitInstance`
- Call API + hiển thị: `MainActivity`

---

## 10. HTTP Requests & Responses

### 10.1. Các HTTP method phổ biến

- `@GET` lấy dữ liệu
- `@POST` tạo mới
- `@PUT` cập nhật toàn bộ
- `@PATCH` cập nhật một phần
- `@DELETE` xoá

Ví dụ (minh hoạ):

```kotlin
@GET("albums/{id}")
suspend fun getAlbumDetail(@Path("id") id: Int): Response<AlbumItem>
```

### 10.2. Đọc `Response` đúng cách

Khi nhận `Response<T>`, hãy kiểm tra:

- `response.isSuccessful`
- `response.code()` (200, 201, 400, 401, 404, 500, …)
- `response.body()` (thành công)
- `response.errorBody()` (thất bại)

Ví dụ:

```kotlin
val response = retrofitService.getSpecificAlbums(6)
if (response.isSuccessful) {
    val data = response.body()
} else {
    val error = response.errorBody()?.string()
}
```

### 10.3. Bắt lỗi mạng (khuyến nghị)

Khi gọi mạng có thể lỗi (mất mạng, timeout…). Nên bọc `try/catch`:

```kotlin
try {
    val response = retrofitService.getAlbums()
} catch (e: Exception) {
    // IOException/HttpException tuỳ trường hợp
}
```

---

## 11. Query Parameters

Query parameter là phần `?key=value` trên URL.

### 11.1. `@Query`

Trong project:

```kotlin
@GET("/albums")
suspend fun getSpecificAlbums(@Query("userId") userId: Int): Response<Albums>
```

URL tạo ra: `.../albums?userId=6`

### 11.2. `@QueryMap` (nâng cao)

Khi có nhiều query:

```kotlin
@GET("albums")
suspend fun getAlbumsByFilters(
    @QueryMap filters: Map<String, String>
): Response<Albums>
```

Gọi:

```kotlin
val filters = mapOf("userId" to "6", "_sort" to "id", "_order" to "desc")
```

---

## 12. Path Parameters

Path parameter là phần nằm trong đường dẫn URL, ví dụ: `/albums/10`.

Khai báo bằng `@Path`:

```kotlin
@GET("albums/{id}")
suspend fun getAlbumDetail(@Path("id") id: Int): Response<AlbumItem>
```

Gọi:

```kotlin
val response = retrofitService.getAlbumDetail(10)
```

---

## 13. Receiving JSON to Logcat

Có 2 cách phổ biến để “nhìn thấy” dữ liệu trả về:

### 13.1. Log bằng code (dễ hiểu cho người mới)

```kotlin
val response = retrofitService.getSpecificAlbums(6)
if (response.isSuccessful) {
    val albums = response.body()
    Log.d("API", "albums = $albums")
} else {
    Log.e("API", "error = ${response.code()}")
}
```

> Nếu muốn log ra JSON “đẹp” hơn, bạn có thể dùng Gson: `Gson().toJson(albums)`.

### 13.2. Log tự động bằng OkHttp Logging Interceptor (khuyến nghị khi debug)

Chỉ cần cấu hình interceptor ở `RetrofitInstance` như phần [8.2](#retrofit-log-interceptor), Logcat sẽ có đầy đủ request/response.

---

## 14. Displaying JSON into TextView

Trong project, `MainActivity` đang:

- Gọi API bằng Retrofit
- Lặp qua danh sách album
- Append title vào `TextView`

Ví dụ tương tự:

```kotlin
val albumsList = response.body()?.listIterator()
if (albumsList != null) {
    while (albumsList.hasNext()) {
        val albumItem = albumsList.next()
        textView.append("Album Title: ${albumItem.title}\n")
    }
}
```

Gợi ý khi dữ liệu nhiều:

- Dùng `RecyclerView` + Adapter để hiển thị danh sách thay vì `TextView.append`.
- Gọi API trong `ViewModel` và quan sát bằng `LiveData/StateFlow` để code sạch hơn (đặc biệt khi app lớn).

---

## 15. Network Security Rules

Phần này giải thích **Network Security** trên Android (thường gọi là *Network Security Configuration*) dành cho người mới. Đây là “luật” giúp Android quyết định:

- App có được phép gọi **HTTP (cleartext)** hay bắt buộc **HTTPS**.
- App tin cậy **chứng chỉ** (certificate) nào khi bắt tay TLS/SSL.
- Có áp dụng **certificate pinning** hay không (tăng bảo mật, nhưng cần quản lý cẩn thận).

Khi dùng Retrofit, bạn sẽ gọi mạng thông qua **OkHttp**; mọi quy định Network Security của Android đều ảnh hưởng trực tiếp đến Retrofit (ví dụ: bị chặn HTTP, lỗi chứng chỉ…).

> Ghi chú: API ví dụ trong tài liệu này (`https://jsonplaceholder.typicode.com`) là **HTTPS**, nên bạn thường không cần nới lỏng rule nào. Phần này hữu ích khi bạn làm việc với API nội bộ/dev, proxy debug, hoặc muốn tăng bảo mật.
>
> Lưu ý: Network Security Configuration được hỗ trợ chính thức từ **Android 7.0 (API 24)** trở lên. Trên thiết bị thấp hơn, file cấu hình có thể bị bỏ qua.

### 15.1. Vì sao cần Network Security Rules?

Người mới thường gặp các tình huống sau:

- Gọi API bằng `http://...` trên Android 9+ (API 28+) bị lỗi:
  - `CLEARTEXT communication to ... not permitted by network security policy`
- Dùng proxy debug (Charles/Burp/mitmproxy) để bắt gói tin nhưng app báo lỗi SSL:
  - `javax.net.ssl.SSLHandshakeException`
- API dùng chứng chỉ tự ký (self-signed) trong môi trường nội bộ → app không tin cậy.
- Muốn tăng bảo mật bằng pin certificate/public key để giảm rủi ro bị MITM.

### 15.2. Khái niệm nền tảng (cần biết)

**HTTP (cleartext)**:
- Dữ liệu gửi/nhận không được mã hoá.
- Dễ bị nghe lén/chỉnh sửa trên mạng công cộng.
- Android hiện đại thường **chặn mặc định** nếu app target API cao.

**HTTPS (TLS/SSL)**:
- Dữ liệu được mã hoá khi truyền.
- Server phải có chứng chỉ hợp lệ và được tin cậy.

**Trust (tin cậy chứng chỉ)**:
- Thông thường app tin cậy “kho chứng chỉ hệ thống” (system CA).
- Khi debug, bạn có thể muốn tin cậy thêm “user-added CA” (chứng chỉ do người dùng cài vào máy) để proxy bắt gói.

**Certificate pinning**:
- App chỉ tin cậy một tập chứng chỉ/khóa công khai cụ thể (pin).
- Bảo mật hơn, nhưng nếu server đổi chứng chỉ mà bạn không cập nhật pin → app sẽ không kết nối được.

### 15.3. Network Security Configuration nằm ở đâu?

Bạn sẽ tạo file XML trong:

- `app/src/main/res/xml/network_security_config.xml`

Sau đó khai báo trong `AndroidManifest.xml` (thẻ `<application>`):

```xml
<application
    android:networkSecurityConfig="@xml/network_security_config"
    ... >
```

Các bước làm nhanh (chuẩn cho người mới):

1. Tạo file `app/src/main/res/xml/network_security_config.xml` (nếu chưa có thư mục `xml` thì tạo).
2. Thêm `android:networkSecurityConfig="@xml/network_security_config"` vào `<application>`.
3. Rebuild/Run app để kiểm tra (nếu đang lỗi cleartext/SSL, đọc Logcat để xác nhận thay đổi có hiệu lực).

> Mẹo: `android:usesCleartextTraffic="true"` cũng có thể bật HTTP, nhưng thường “thô” và khó kiểm soát theo domain. Cấu hình qua `networkSecurityConfig` rõ ràng và an toàn hơn.

### 15.4. Cấu trúc file `network_security_config.xml`

Khung cơ bản:

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>

    <!-- Luật chung (áp dụng nếu không có domain-config match) -->
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>

    <!-- Luật riêng theo domain -->
    <domain-config cleartextTrafficPermitted="false">
        <domain includeSubdomains="true">example.com</domain>
    </domain-config>

</network-security-config>
```

Giải thích nhanh:

- `<base-config>`: luật mặc định cho mọi kết nối.
- `cleartextTrafficPermitted`:
  - `false`: chặn HTTP, chỉ cho HTTPS.
  - `true`: cho phép HTTP (không khuyến nghị cho production).
- `<domain-config>`: luật áp dụng cho domain cụ thể.
- `<domain includeSubdomains="true">`: áp dụng cho cả subdomain (vd `api.example.com`).
- `<trust-anchors>`:
  - `system`: tin cậy CA hệ thống (mặc định nên có).
  - `user`: tin cậy CA người dùng cài thêm (hữu ích khi debug proxy).

### 15.5. Các cấu hình mẫu (copy dùng ngay)

#### A) Production (khuyến nghị): Chỉ HTTPS + chỉ tin CA hệ thống

`app/src/main/res/xml/network_security_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
</network-security-config>
```

Khi đó:
- Nếu bạn lỡ gọi `http://...` → sẽ bị chặn.
- Nếu API dùng chứng chỉ hợp lệ (CA tin cậy) → hoạt động bình thường.

#### B) Debug bắt gói (Charles/Burp): Tin thêm `user` CA (chỉ nên dùng debug)

`app/src/debug/res/xml/network_security_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
</network-security-config>
```

Nếu `AndroidManifest.xml` (main) đã trỏ tới `@xml/network_security_config`, thì **không cần** tạo manifest riêng cho debug: Android sẽ tự ưu tiên resource trong `src/debug/` khi bạn chạy build debug.

> Vì sao đặt ở `src/debug/`? Để bản release không vô tình tin cậy chứng chỉ do người dùng cài (tăng rủi ro MITM).

#### C) Cho phép HTTP chỉ với một domain cụ thể (nội bộ/dev)

Ví dụ bạn có server dev chạy HTTP tại `dev.example.local` (hoặc domain nội bộ có DNS):

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <!-- Mặc định: chặn HTTP -->
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>

    <!-- Riêng domain dev: cho phép HTTP -->
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">dev.example.local</domain>
    </domain-config>
</network-security-config>
```

> Lưu ý: Với địa chỉ dạng IP (vd `http://10.0.2.2`), cấu hình theo domain có thể không áp dụng như mong muốn. Cách “an toàn” hơn là dùng HTTPS hoặc dùng domain nội bộ trỏ về IP đó.

#### D) Certificate pinning bằng Network Security Config (nâng cao)

Android hỗ trợ pinning trong `network_security_config.xml` (API 24+). Ý tưởng:
- App chỉ chấp nhận chứng chỉ có **public key hash** khớp pin.
- Nên có **ít nhất 2 pin** (1 chính + 1 dự phòng) và đặt `expiration`.

Ví dụ (minh hoạ):

```xml
<network-security-config>
    <domain-config cleartextTrafficPermitted="false">
        <domain includeSubdomains="true">api.example.com</domain>

        <pin-set expiration="2027-01-01">
            <!-- pin dự phòng để xoay chứng chỉ -->
            <pin digest="SHA-256">BASE64_SHA256_PIN_1==</pin>
            <pin digest="SHA-256">BASE64_SHA256_PIN_2==</pin>
        </pin-set>
    </domain-config>
</network-security-config>
```

> Cảnh báo: Pinning sai hoặc hết hạn có thể làm app “mất mạng” hoàn toàn với domain đó. Chỉ áp dụng khi bạn kiểm soát server và có quy trình xoay chứng chỉ rõ ràng.

### 15.6. Liên hệ với Retrofit/OkHttp (thực tế khi debug lỗi)

Khi gặp lỗi gọi API với Retrofit, hãy phân biệt:

- **Bị chặn cleartext (HTTP)**:
  - Dấu hiệu: thông báo “CLEARTEXT communication not permitted…”
  - Cách xử lý: đổi sang HTTPS, hoặc cấu hình `network_security_config.xml` cho phép HTTP (tốt nhất chỉ debug/dev).

- **Lỗi SSL handshake**:
  - Dấu hiệu: `SSLHandshakeException`, `CertPathValidatorException`, `Trust anchor for certification path not found`
  - Cách xử lý:
    - Đảm bảo server dùng chứng chỉ hợp lệ.
    - Debug proxy: thêm `user` CA cho build debug như mục 15.5(B).
    - Không “tắt SSL verification” bừa bãi trong production.

- **Pinning fail** (nếu bật pinning):
  - Dấu hiệu: lỗi handshake dù chứng chỉ hợp lệ.
  - Cách xử lý: cập nhật pin, đảm bảo pin dự phòng, kiểm tra ngày hết hạn pin-set.

### 15.7. Checklist nhanh cho người mới

- Dùng **HTTPS** cho mọi API khi có thể.
- Nếu cần HTTP (dev/nội bộ), chỉ cho phép ở **debug** hoặc theo **domain cụ thể**.
- Bản release: chỉ tin cậy `system` CA; tránh thêm `user`.
- Nếu áp dụng pinning: có pin dự phòng + quy trình cập nhật/rotation.
- Khi lỗi, đọc log và xác định: cleartext bị chặn hay SSL handshake/pinning.
